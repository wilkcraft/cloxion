<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Cloxion</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        background-color: #f0f4f8;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        margin: 0;
        overflow: hidden;
      }

      .login-container,
      .chat-container {
        background-color: white;
        border-radius: 8px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        padding: 20px;
        width: 90%;
        max-width: 400px;
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      .login-container h2 {
        margin-bottom: 10px;
      }

      .login-container input {
        margin: 10px 0;
        padding: 10px;
        width: 100%;
        border-radius: 5px;
        border: 1px solid #ccc;
        background-color: #fff;
        color: #000;
      }

      .login-container input::placeholder {
        color: #777;
      }

      .login-container button {
        background-color: #00bcd4;
        color: white;
        border: none;
        padding: 10px;
        width: 100%;
        border-radius: 5px;
        cursor: pointer;
        transition: background-color 0.3s ease;
      }

      .login-container button:hover {
        background-color: #0097a7;
      }

      .chat-container {
        display: none; /* por defecto est√° oculto */
        height: 98vh;
        max-width: 100vw; /* que nunca supere la pantalla */
        margin-left: 0;
        flex-direction: column;
        background-color: white;
        border-radius: 8px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        overflow: hidden;
      }

      .chat-header {
        background-color: #00bcd4;
        color: white;
        padding: 10px 15px;
        font-weight: bold;
        width: 100%;
        display: flex;
        flex-direction: column;
        justify-content: center;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }

      .chat-header-top {
        display: flex;
        align-items: center;
        justify-content: space-between;
      }

      .chat-status {
        font-size: 13px;
        font-weight: 500;
        color: #e0f7fa;
        margin-top: 2px;
        text-shadow: 0 0 3px rgba(0, 0, 0, 0.2);
        animation: fadeStatus 0.3s ease-in-out;
      }

      /* Animaci√≥n suave al actualizar estado */
      @keyframes fadeStatus {
        from {
          opacity: 0;
          transform: translateY(-3px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }
      .menu-icon {
        margin-right: 8px;
        cursor: pointer;
        font-size: 22px;
        color: white;
        vertical-align: middle;
      }

      .chat-messages {
        flex-grow: 1;
        overflow-y: auto;
        padding: 20px;
        width: 100%;
      }

      .message {
        margin-bottom: 10px;
        padding: 8px 12px;
        border-radius: 18px;
        max-width: 65%; /* ‚úÖ Mantiene el l√≠mite m√°ximo actual */
        width: fit-content; /* ‚úÖ Se ajusta al texto */
        word-wrap: break-word;
        position: relative;
        white-space: pre-wrap; /* ‚úÖ Mantiene saltos de l√≠nea */
        overflow-wrap: break-word; /* ‚úÖ Evita desbordes de texto largos */
      }

      .message.sent {
        background-color: #e0ffff;
        align-self: flex-end;
        margin-left: auto;
      }

      .message.received {
        background-color: #fffacd;
        align-self: flex-start;
        margin-right: auto;
      }

      .chat-input {
        display: flex;
        padding: 10px;
        width: 100%;
        background-color: #e9ecef;
      }

      .chat-input input {
        flex-grow: 1;
        border: none;
        border-radius: 20px;
        padding: 10px;
        outline: none;
      }

      .chat-input button {
        background-color: #00bcd4;
        color: white;
        border: none;
        border-radius: 50%;
        width: 40px;
        height: 40px;
        font-size: 18px;
      }

      .context-menu {
        position: absolute;
        background: #ffffff;
        border: 1px solid #ccc;
        border-radius: 8px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        z-index: 1000;
        padding: 5px;
        display: flex;
        flex-direction: column;
        min-width: 110px;
        animation: fadeIn 0.1s ease-out;
      }

      .context-menu button {
        background: none;
        border: none;
        text-align: left;
        padding: 8px 12px;
        width: 100%;
        cursor: pointer;
        font-size: 14px;
        color: #333;
      }

      .context-menu button:hover {
        background: #f2f2f2;
      }

      .user-list {
        position: absolute;
        left: 0;
        top: 0;
        height: 100%;
        width: 220px;
        background: #ffffff;
        border-right: 1px solid #e0e0e0;
        box-shadow: 2px 0 6px rgba(0, 0, 0, 0.05);
        padding: 15px 0;
        display: flex;
        flex-direction: column;
        z-index: 50;
        overflow-y: auto !important;
      }

      .user-list strong {
        text-align: center;
        font-size: 18px;
        color: #00bcd4;
        margin-bottom: 15px;
        display: block;
        font-weight: bold;
        letter-spacing: 0.5px;
      }

      .user-item {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 10px 15px;
        margin: 3px 8px;
        border-radius: 10px;
        cursor: pointer;
        transition: background 0.2s ease, transform 0.1s ease;
      }

      .user-item:hover {
        background: #e0f7fa;
        transform: translateX(2px);
      }

      .user-item.active {
        background: #b2ebf2;
        font-weight: bold;
      }

      .user-avatar {
        width: 35px;
        height: 35px;
        border-radius: 50%;
        background: #00bcd4;
        color: white;
        display: flex;
        justify-content: center;
        align-items: center;
        font-weight: bold;
        font-size: 16px;
        box-shadow: 0 2px 4px rgba(0, 188, 212, 0.3);
      }

      .admin-item {
        background: #e3f2fd;
        border: 1px solid #90caf9;
        margin: 6px 8px;
      }

      .admin-item:hover {
        background: #bbdefb;
      }

      .message-time {
        display: block;
        font-size: 11px;
        color: #555;
        text-align: right;
        margin-top: 3px;
      }

      .date-separator {
        text-align: center;
        margin: 15px 0;
        color: #777;
        font-weight: bold;
        font-size: 13px;
        position: relative;
      }

      .date-separator::before,
      .date-separator::after {
        content: "";
        position: absolute;
        top: 50%;
        width: 35%;
        height: 1px;
        background: #ccc;
      }

      .date-separator::before {
        left: 0;
      }

      .date-separator::after {
        right: 0;
      }

      /* üü¶ Recuadro de inicio de chat */
      .chat-start {
        text-align: center;
        background: #d1ecf1;
        color: #0c5460;
        padding: 8px 12px;
        border-radius: 10px;
        margin: 10px auto;
        width: fit-content;
        max-width: 80%;
        font-size: 14px;
        font-weight: 600;
        font-family: Arial, sans-serif;
      }

      #toggle-user-list {
        display: none;
      }

      /* ‚ú® Animaciones de desplazamiento */
      @keyframes scrollUp {
        from {
          transform: translateY(10px);
          opacity: 0.6;
        }
        to {
          transform: translateY(0);
          opacity: 1;
        }
      }

      @keyframes scrollDown {
        from {
          transform: translateY(-10px);
          opacity: 0.6;
        }
        to {
          transform: translateY(0);
          opacity: 1;
        }
      }

      .chat-messages.scroll-up {
        animation: scrollUp 0.3s ease-out;
      }

      .chat-messages.scroll-down {
        animation: scrollDown 0.3s ease-out;
      }

      /* === LOGO Cloxion === */
      .cloxion-modern {
        font-weight: 700;
        font-size: 30px;
        letter-spacing: 1.5px;
        position: relative;
        color: #0a0f12; /* texto oscuro */
        text-align: center;
        font-family: "Poppins", "Inter", system-ui, sans-serif;
        margin-bottom: 8px;
      }

      .cloxion-modern .c {
        position: relative; /* necesario para que el ::before se posicione correctamente */
        display: inline-block;
      }

      .cloxion-modern .c::before {
        content: "";
        position: absolute;
        top: -5px;
        left: -6px;
        width: 9px;
        height: 9px;
        background: radial-gradient(circle, #00bcd4 0%, #0097a7 80%);
        box-shadow: 0 0 4px rgba(0, 188, 212, 0.5);
        border-radius: 50%;
      }

      .cloxion-modern .x {
        color: #00bcd4;
        position: relative;
      }

      .cloxion-modern .x::after {
        content: "";
        position: absolute;
        left: 0;
        right: 0;
        top: 50%;
        height: 2px;
        background: linear-gradient(45deg, #00bcd4, #00a3c4);
        transform: rotate(45deg);
        opacity: 0.8;
      }

      /* === Isotipo === */
      .cloxion-x {
        position: relative;
        width: 60px;
        height: 60px;
        background: radial-gradient(circle at 50% 50%, #00c4d4, #008ba3 85%);
        border-radius: 22%;
        box-shadow: inset 0 0 10px rgba(255, 255, 255, 0.2),
          0 0 18px rgba(0, 188, 212, 0.3);
        overflow: hidden;
      }

      /* L√≠neas diagonales */
      .cloxion-x::before,
      .cloxion-x::after {
        content: "";
        position: absolute;
        top: 45%;
        left: -25%;
        width: 150%;
        height: 6px;
        border-radius: 6px;
        background: linear-gradient(
          90deg,
          transparent,
          #ffffff 40%,
          transparent
        );
        opacity: 0.85;
      }
      .cloxion-x::before {
        transform: rotate(45deg);
      }
      .cloxion-x::after {
        transform: rotate(-45deg);
      }

      /* N√∫cleo central */
      .cloxion-x .core {
        position: absolute;
        top: 50%;
        left: 50%;
        width: 16px;
        height: 16px;
        border-radius: 50%;
        transform: translate(-50%, -50%);
        background: radial-gradient(circle, #ffffff, #b2ebf2 60%, #00bcd4 100%);
        box-shadow: 0 0 12px rgba(255, 255, 255, 0.9),
          0 0 20px rgba(0, 188, 212, 0.5);
      }

      /* Pulso */
      @keyframes pulseCore {
        0%,
        100% {
          transform: translate(-50%, -50%) scale(1);
        }
        50% {
          transform: translate(-50%, -50%) scale(1.15);
        }
      }

      /* √ìrbita */
      .cloxion-x .orbit {
        position: absolute;
        top: 50%;
        left: 50%;
        width: 135%;
        height: 135%;
        border-radius: 50%;
        border: 1.5px solid rgba(255, 255, 255, 0.4);
        transform: translate(-50%, -50%);
        animation: rotateOrbit 7s linear infinite;
      }
      @keyframes rotateOrbit {
        from {
          transform: translate(-50%, -50%) rotate(0deg);
        }
        to {
          transform: translate(-50%, -50%) rotate(360deg);
        }
      }

      /* Sat√©lite */
      .cloxion-x .satellite {
        position: absolute;
        top: 0%;
        left: 50%;
        width: 7px;
        height: 7px;
        border-radius: 50%;
        background: radial-gradient(circle, #fff, #b2ebf2);
        transform: translate(-50%, -50%);
        box-shadow: 0 0 6px rgba(255, 255, 255, 0.8);
      }

      .cloxion-header {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 12px;
        margin-bottom: 12px;
      }

      .cloxion-header .cloxion-icon {
        margin: 0; /* quitar m√°rgenes que lo desalineaban verticalmente */
      }

      .cloxion-header .cloxion-modern {
        margin: 0;
        text-align: left;
      }

      /* ---- Barra de mensaje fijado (arriba del chat) ---- */
      #pinned-message {
        max-width: 100%;
        overflow: hidden;
        box-sizing: border-box;
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 8px 12px;
        color: white;
        font-weight: 600;
        cursor: pointer;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.08);
        border-bottom-left-radius: 6px;
        border-bottom-right-radius: 6px;
      }

      /* Icono y texto truncado */
      #pinned-message .pin-icon {
        font-size: 18px;
        margin-right: 6px;
      }
      #pinned-message .pin-text {
        flex: 1;
        min-width: 0;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        display: block;
        max-width: calc(100% - 60px);
      }

      /* Bot√≥n para quitar fijado */
      #pinned-message .pin-unpin {
        margin-left: auto;
        background: rgba(255, 255, 255, 0.18);
        border: none;
        color: white;
        padding: 6px 8px;
        border-radius: 6px;
        cursor: pointer;
      }

      /* ---- Vista previa de respuesta ---- */
      #reply-preview {
        position: absolute;
        bottom: 65px;
        width: 80%;
        box-sizing: border-box;
        padding: 8px 12px;
        border-left: 4px solid rgba(0, 0, 0, 0.12);
        background: #f6f7f9;
        display: flex;
        align-items: center;
        gap: 10px;
        font-size: 13px;
        border-bottom: 1px solid #ddd;
        z-index: 15;
      }
      #reply-preview .reply-text {
        flex: 1;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      #reply-preview .reply-cancel {
        background: none;
        border: none;
        font-size: 18px;
        cursor: pointer;
      }

      /* ---- Resaltado moment√°neo para salto ---- */
      .message.highlight {
        position: relative;
        overflow: hidden;
      }

      .message.highlight::after {
        content: "";
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(
          90deg,
          transparent,
          rgba(0, 188, 212, 0.25),
          transparent
        );
        animation: slideHighlight 1.2s ease;
      }

      @keyframes slideHighlight {
        0% {
          left: -100%;
        }
        50% {
          left: 0%;
        }
        100% {
          left: 100%;
        }
      }

      /* === Bot√≥n de scroll al final del chat === */
      .scroll-to-bottom-btn {
        position: absolute;
        bottom: 80px;
        right: 20px;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background-color: #00bcd4;
        color: white;
        border: none;
        cursor: pointer;
        font-size: 20px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 100;
        transition: all 0.3s ease;
      }

      .scroll-to-bottom-btn:hover {
        background-color: #0097a7;
        transform: scale(1.1);
      }

      .scroll-to-bottom-btn.visible {
        display: flex;
      }

      /* === üü¶ Panel de anuncios === */
      #broadcast-panel {
        display: none;
        flex-direction: column;
        align-items: center;
        padding: 10px;
        border-top: 1px solid #ccc;
        border-bottom: 1px solid #ccc;
        background: #e9ecef;
      }

      #broadcast-panel h4 {
        margin: 5px 0;
        color: #00bcd4;
      }

      #broadcast-input {
        width: 90%;
        height: 70px;
        flex-grow: 1;
        border: none;
        border-radius: 10px;
        padding: 10px;
        outline: none;
        resize: none;
        margin-bottom: 8px;
        font-family: inherit;
        font-size: 14px;
      }

      #broadcast-send {
        background: #00bcd4;
        color: white;
        border: none;
        padding: 8px 12px;
        border-radius: 6px;
        cursor: pointer;
        transition: background-color 0.3s ease;
      }

      #broadcast-send:hover {
        background: #0097a7;
      }

      #toggle-broadcast {
        margin: 10px auto;
        width: 90%;
        padding: 8px;
        background: #00bcd4;
        color: white;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        transition: background-color 0.3s ease;
      }

      #toggle-broadcast:hover {
        background: #0097a7;
      }

      /* === POPUP CREAR GRUPO === */
      .popup-overlay {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.4);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1000;
      }

      .popup {
        background: #ffffff;
        border-radius: 12px;
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2);
        width: 90%;
        max-width: 380px;
        padding: 20px;
        animation: fadeInPopup 0.3s ease;
      }

      .popup h3 {
        color: #00bcd4;
        text-align: center;
        margin-bottom: 15px;
      }

      .popup .contact-list {
        max-height: 250px;
        overflow-y: auto;
        border: 1px solid #ddd;
        border-radius: 8px;
        padding: 8px;
        margin-bottom: 15px;
      }

      .popup .contact-item {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 6px 8px;
        border-radius: 8px;
        cursor: pointer;
        transition: background 0.2s;
      }

      .popup .contact-item:hover {
        background: #e0f7fa;
      }

      .popup .contact-item.selected {
        background: #b2ebf2;
        font-weight: bold;
      }

      .popup button {
        background: #00bcd4;
        color: white;
        border: none;
        border-radius: 6px;
        padding: 10px 15px;
        cursor: pointer;
        width: 100%;
        margin-top: 10px;
        transition: background-color 0.3s;
      }

      .popup button:hover {
        background: #0097a7;
      }

      @keyframes fadeInPopup {
        from {
          opacity: 0;
          transform: scale(0.9);
        }
        to {
          opacity: 1;
          transform: scale(1);
        }
      }

      /* === Mensajes de grupo con avatar y nombre alineados === */
      .group-message {
        display: flex;
        align-items: center; /* ‚úÖ centrado vertical */
        gap: 10px;
        margin-bottom: 12px;
        max-width: 90%;
      }

      .group-message .user-avatar.small {
        flex-shrink: 0;
        width: 28px;
        height: 28px;
        font-size: 13px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 1px 3px rgba(0, 188, 212, 0.2);
      }

      .group-message .message-content {
        display: flex;
        flex-direction: column;
        justify-content: center;
        max-width: 100%;
      }

      @media (min-width: 769px) {
        .chat-container {
          margin-left: 220px; /* ancho de .user-list */
          max-width: calc(100vw - 220px); /* no sobresalir de la pantalla */
        }

        #toggle-user-list {
          display: none !important; /* Ocultamos el bot√≥n flotante */
        }
      }

      /* Modo m√≥vil */
      @media (max-width: 768px) {
        body {
          overflow: hidden;
          height: 100dvh;
          display: block;
        }

        .login-container {
          position: fixed;
          left: 50%;
          top: 50%;
          transform: translate(-50%, -50%);
          width: calc(100% - 32px);
          max-width: 420px;
          margin: 0;
          box-sizing: border-box;
          max-height: 90dvh;
          overflow: auto;
          -webkit-overflow-scrolling: touch;
        }

        .chat-container {
          height: 100dvh;
          max-height: 100dvh;
          flex-direction: column;
          overflow: hidden;
          padding-top: 0;
        }

        .chat-messages {
          flex: 1;
          overflow-y: auto;
          -webkit-overflow-scrolling: touch;
          scroll-behavior: smooth;
          max-width: 90%;
        }

        .chat-header {
          margin-top: 0;
          flex-shrink: 0;
          position: sticky;
          top: 0;
          z-index: 10;
        }

        .chat-input {
          flex-shrink: 0;
          position: sticky;
          bottom: 0;
          z-index: 10;
        }

        .user-list {
          display: none;
          position: fixed;
          left: 0;
          top: 0;
          height: 100%;
          z-index: 100;
          background: #ffffff;
          box-shadow: 2px 0 6px rgba(0, 0, 0, 0.2);
          transition: transform 0.3s ease;
          transform: translateX(-100%);
        }

        .user-list.show {
          transform: translateX(0);
          display: flex;
        }

        /* Fondo semitransparente al abrir men√∫ (solo m√≥vil) */
        .overlay {
          display: none;
          position: fixed;
          inset: 0;
          background: rgba(0, 0, 0, 0.3);
          z-index: 40; /* debajo del men√∫ (que tiene z-index:100) */
          transition: opacity 0.3s ease;
        }

        .overlay.show {
          display: block;
          opacity: 1;
        }

        /* Bot√≥n para abrir/cerrar men√∫ */
        #toggle-user-list {
          display: none !important; /* Ocultamos el bot√≥n flotante */
        }
      }

      /* üåô MODO OSCURO */
      @media (prefers-color-scheme: dark) {
        body {
          background-color: #121212;
          color: white;
        }

        .login-container {
          background-color: #1e1e1e;
          box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
        }

        .login-container input {
          background-color: #2b2b2b;
          border: 1px solid #444;
          color: white;
        }

        .login-container input::placeholder {
          color: #b0b0b0;
        }

        .login-container button {
          background-color: #00838f;
        }

        .login-container button:hover {
          background-color: #00acc1;
        }

        .chat-container {
          background-color: #1e1e1e;
          box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
        }

        .chat-messages {
          background-color: #1e1e1e;
        }

        .chat-header {
          background-color: #00838f;
        }

        .message.sent {
          background-color: #00796b;
        }

        .message.received {
          background-color: #bbaa55;
          box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }

        .chat-input {
          background-color: #2c2c2c;
        }

        .chat-input input {
          background-color: #3a3a3a;
          color: #ffffff;
        }

        .chat-input input::placeholder {
          color: #b0b0b0;
        }

        .chat-input button {
          background-color: #00838f;
        }

        .context-menu {
          background: #2b2b2b;
          border: 1px solid #555;
          box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
        }

        .context-menu button {
          color: #ddd;
        }

        .context-menu button:hover {
          background: #3a3a3a;
        }

        @keyframes fadeIn {
          from {
            opacity: 0;
            transform: translateY(-5px);
          }
          to {
            opacity: 1;
            transform: translateY(0);
          }
        }

        .user-list {
          background: #1e1e1e;
          border-right: 1px solid #333;
          box-shadow: 2px 0 6px rgba(255, 255, 255, 0.05);
        }

        .user-list strong {
          color: #00acc1;
        }

        .user-item {
          color: #ddd;
        }

        .user-item:hover {
          background: #004d40;
        }

        .user-item.active {
          background: #00695c;
          font-weight: bold;
        }

        .user-avatar {
          background: #00acc1;
          color: #fff;
          box-shadow: 0 2px 4px rgba(0, 172, 193, 0.4);
        }

        .admin-item {
          background: #003c4f;
          border: 1px solid #00838f;
        }

        .admin-item:hover {
          background: #004d61;
        }

        .message-time {
          color: #bbb;
        }
        .date-separator {
          color: #ccc;
        }
        .date-separator::before,
        .date-separator::after {
          background: #555;
        }

        /* üîµ Contador de mensajes no le√≠dos */
        .unread-badge {
          background-color: #ff3b30;
          color: white;
          border-radius: 50%;
          padding: 2px 6px;
          font-size: 12px;
          font-weight: bold;
          margin-left: auto;
          display: none;
        }

        .chat-start {
          background: #004d61;
          color: #b2ebf2;
        }

        .cloxion-modern {
          color: #e0f7fa;
        }

        .cloxion-modern .x {
          color: #03818f; /* azul m√°s brillante para la ‚Äúx‚Äù */
        }

        .cloxion-modern .c::before {
          background: #03818f; /* punto brillante */
        }

        .cloxion-modern .x::after {
          background: linear-gradient(45deg, #00e5ff, #00acc1);
          opacity: 0.9;
        }

        .cloxion-x {
          background: radial-gradient(circle at 50% 50%, #0097a7, #003c4f 85%);
          box-shadow: inset 0 0 10px rgba(255, 255, 255, 0.1),
            0 0 22px rgba(0, 229, 255, 0.25);
        }
        .cloxion-x::before,
        .cloxion-x::after {
          background: linear-gradient(
            90deg,
            transparent,
            #00e5ff 40%,
            transparent
          );
        }
        .cloxion-x .core {
          background: radial-gradient(circle, #00e5ff, #00acc1 70%, #006978);
          box-shadow: 0 0 14px rgba(0, 229, 255, 0.8),
            0 0 28px rgba(0, 229, 255, 0.5);
        }

        .chat-status {
          color: #b2ebf2;
        }

        #pinned-message {
          background: #00838f;
        }
        #reply-preview {
          background: #2b2b2b;
          border-left-color: rgba(255, 255, 255, 0.08);
          color: #ddd;
        }

        .scroll-to-bottom-btn {
          background-color: #00838f;
        }

        .scroll-to-bottom-btn:hover {
          background-color: #00acc1;
        }

        /* === üü¶ Panel de anuncios === */
        #broadcast-panel {
          background-color: #2c2c2c;
        }

        #broadcast-panel h4 {
          color: #00838f;
        }

        #broadcast-input {
          background-color: #3a3a3a;
          color: #ffffff;
        }

        #broadcast-send {
          background: #00838f;
        }

        #toggle-broadcast {
          background: #00838f;
        }

        .popup {
          background: #1e1e1e;
          color: #fff;
          box-shadow: 0 4px 15px rgba(0, 0, 0, 0.6);
        }
        .popup .contact-item:hover {
          background: #004d40;
        }
        .popup .contact-item.selected {
          background: #00695c;
        }
        .popup button {
          background: #00838f;
        }
        .popup button:hover {
          background: #00acc1;
        }

        .group-message .user-avatar.small {
          background: #00acc1;
          box-shadow: 0 1px 3px rgba(0, 172, 193, 0.3);
        }
      }
    </style>
  </head>
  <body>
    <!-- LOGIN -->
    <div class="login-container" id="login-container">
      <h2>Iniciar sesi√≥n</h2>
      <input type="text" id="username" placeholder="Usuario" />
      <input type="password" id="password" placeholder="Contrase√±a" />
      <button onclick="login()">Entrar</button>
      <p id="login-error" style="color: red; display: none">
        Usuario o contrase√±a incorrectos
      </p>
    </div>

    <!-- CHAT -->
    <div class="chat-container" id="chat-container">
      <button id="toggle-user-list">‚ò∞</button>
      <div class="user-list" id="user-list">
        <!-- === Logo Cloxion con isotipo === -->
        <div class="cloxion-header">
          <div class="cloxion-x" aria-hidden="true">
            <div class="core"></div>
          </div>
          <div class="cloxion-modern">
            <span class="c">C</span>lo<span class="x">x</span>ion
          </div>
        </div>
      </div>

      <div class="overlay" id="overlay"></div>
      <div class="chat-header" id="chat-header">
        <div class="chat-header-top">
          <span id="chat-name">Chat</span>
        </div>
        <div id="chat-status" class="chat-status"></div>
      </div>

      <!-- Barra de mensaje fijado (estilo WhatsApp) -->
      <div id="pinned-message" style="display: none"></div>

      <!-- Vista previa de respuesta sobre el input -->
      <div id="reply-preview" style="display: none"></div>
      <div class="chat-messages" id="chat-messages"></div>
      <div class="chat-input">
        <input
          type="text"
          id="message-input"
          placeholder="Escribe un mensaje..."
        />
        <button onclick="sendMessage()">‚û§</button>
      </div>

      <button
        class="scroll-to-bottom-btn"
        id="scroll-to-bottom"
        title="Ir al final"
      >
        ‚Üì
      </button>
    </div>

    <script type="module">
      import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-app.js";
      import {
        getFirestore,
        doc,
        setDoc,
        getDoc,
        collection,
        addDoc,
        deleteDoc,
        onSnapshot,
        query,
        where,
        orderBy,
        getDocs,
        serverTimestamp,
        writeBatch,
      } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-firestore.js";

      import {
        getMessaging,
        getToken,
        onMessage,
      } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-messaging.js";

      const firebaseConfig = {
        apiKey: "AIzaSyDLKdKtSocG9hLs8mSggXl0cL4MRcpsW5A",
        authDomain: "iniciosesion-1346.firebaseapp.com",
        projectId: "iniciosesion-1346",
        storageBucket: "iniciosesion-1346.firebasestorage.app",
        messagingSenderId: "746485966333",
        appId: "1:746485966333:web:cbd2b68649a72e936ca594",
        measurementId: "G-ZVE389BCKD",
      };

      const app = initializeApp(firebaseConfig);
      const db = getFirestore(app);

      // === üîî Configurar Firebase Cloud Messaging ===
      const messaging = getMessaging(app);

      // Registrar el service worker
      if ("serviceWorker" in navigator) {
        navigator.serviceWorker
          .register("/firebase-messaging-sw.js")
          .then((reg) => console.log("‚úÖ Service Worker registrado:", reg))
          .catch((err) => console.error("‚ùå Error al registrar SW:", err));
      }

      async function requestPermissionAndSaveToken() {
        try {
          const status = await Notification.requestPermission();
          if (status === "granted") {
            const token = await getToken(messaging, {
              vapidKey:
                "BB7-A6qer7T-AHiBlLDzHMUSQS8h9n5HzL3uWVWgL058042_VWlJW0D32wrZZUCRpjHS6c3yUOS5fCR-bU_yGmg", // ‚ö†Ô∏è cambia esto por tu clave p√∫blica de Firebase
            });
            if (token && currentUser) {
              await setDoc(
                doc(db, "usuarios", currentUser),
                { token },
                { merge: true }
              );
              console.log("üîî Token guardado:", token);
            }
          } else {
            console.warn("‚ùå Permiso de notificaciones denegado");
          }
        } catch (e) {
          console.error("Error al obtener token:", e);
        }
      }

      // Mostrar notificaciones cuando la web est√° abierta
      onMessage(messaging, (payload) => {
        const { title, body } = payload.notification;
        new Notification(title, { body });
      });

      let currentUser = sessionStorage.getItem("currentUser") || null;

      // --- Estado para respuesta y fijado ---
      let replyTo = null; // { id, texto, usuario } cuando se est√° respondiendo
      let pinnedDataLocal = null; // guardamos el objeto del mensaje fijado actual

      let activeChatId = null;
      let activeChatWith = null;

      async function login() {
        const username = document.getElementById("username").value.trim();
        const password = document.getElementById("password").value.trim();
        const errorMsg = document.getElementById("login-error");

        const userRef = doc(db, "usuarios", username);
        const userSnap = await getDoc(userRef);

        if (!userSnap.exists()) {
          if (username === "Miguel" && password === "1346") {
            await setDoc(userRef, { nombre: "Miguel", password: "1346" });
          } else {
            errorMsg.style.display = "block";
            return;
          }
        }

        const userData = (await getDoc(userRef)).data();

        if (userData.password === password) {
          currentUser = username;

          // üü¢ Marcar usuario en l√≠nea
          await setDoc(
            doc(db, "usuarios", username),
            {
              online: true,
              ultimoAcceso: serverTimestamp(),
            },
            { merge: true }
          );

          sessionStorage.setItem("currentUser", username); // ‚úÖ Guardar sesi√≥n temporal

          document.getElementById("login-container").style.display = "none";
          document.getElementById("chat-container").style.display = "flex";
          listenForDeletedGroups();

          initScrollToBottomButton();

          await loadUserList();
          listenForIncomingMessages();

          // üü¶ Activar notificaciones push
          await requestPermissionAndSaveToken();

          activeChatWith = currentUser;
          activeChatId = `${currentUser}_self`; // chat consigo mismo
          updateChatHeader(`${currentUser} (T√∫)`);
          loadMessages(activeChatId);
          attachPinnedListener(activeChatId);

          sessionStorage.setItem("lastChatWith", "Admin"); // üü© Guardar si est√° en su propio chat

          const adminItem = document.querySelector(".admin-item");
          if (adminItem) adminItem.classList.add("active");
        } else {
          errorMsg.style.display = "block";
        }
      }

      // üîÅ Actualizar presencia cada 5 segundos
      setInterval(async () => {
        if (currentUser) {
          await setDoc(
            doc(db, "usuarios", currentUser),
            { ultimoPing: Date.now() },
            { merge: true }
          );

          setTimeout(() => {
            initScrollToBottomButton();
          }, 500);
        }
      }, 5000);

      function getChatId(user1, user2) {
        return [user1, user2].sort().join("_");
      }

      // --- üëÇ Escuchar todos los chats donde participa el usuario ---
      function listenForIncomingMessages() {
        const usersRef = collection(db, "usuarios");

        getDocs(usersRef).then((snapshot) => {
          snapshot.forEach((userDoc) => {
            const user = userDoc.data().nombre;
            if (user === currentUser) return;

            const chatId = getChatId(currentUser, user);
            const q = query(
              collection(db, "chatsPrivados", chatId, "mensajes"),
              where("timestamp", "!=", null),
              orderBy("timestamp")
            );

            onSnapshot(q, (snap) => {
              let unreadCount = 0;
              snap.forEach((msgDoc) => {
                const msg = msgDoc.data();
                if (
                  msg.usuario !== currentUser &&
                  msg.check !== true &&
                  activeChatWith !== user
                ) {
                  unreadCount++;
                }
              });
              updateUnreadBadge(user, unreadCount);
            });
          });
        });
      }

      async function loadUserList() {
        const userList = document.getElementById("user-list");

        // üßπ Limpiar lista de usuarios (manteniendo el logo Cloxion)
        const header = userList.querySelector(".cloxion-header");
        userList.innerHTML = "";
        if (header) userList.appendChild(header);

        // üîπ Crear el usuario "Admin (T√∫)"
        const adminDiv = document.createElement("div");
        adminDiv.classList.add("user-item", "admin-item");
        adminDiv.dataset.name = currentUser;

        const adminAvatar = document.createElement("div");
        adminAvatar.classList.add("user-avatar");
        adminAvatar.textContent = "üß†";

        const adminName = document.createElement("span");
        adminName.textContent = `${currentUser} (T√∫)`;

        adminDiv.appendChild(adminAvatar);
        adminDiv.appendChild(adminName);

        adminDiv.onclick = () => {
          document
            .querySelectorAll(".user-item")
            .forEach((el) => el.classList.remove("active"));
          adminDiv.classList.add("active");

          activeChatWith = currentUser;
          activeChatId = `${currentUser}_self`;

          updateChatHeader(`${currentUser} (T√∫)`);
          loadMessages(activeChatId);
          closeMenuOnMobile();
        };

        userList.appendChild(adminDiv);

        if (currentUser === "Admin" || currentUser === "Miguel") {
          // Bot√≥n para abrir/cerrar el panel
          const toggleBroadcast = document.createElement("button");
          toggleBroadcast.id = "toggle-broadcast";
          toggleBroadcast.textContent = "üì¢ Enviar Novedad";

          // Panel oculto por defecto
          const broadcastContainer = document.createElement("div");
          broadcastContainer.id = "broadcast-panel";

          broadcastContainer.innerHTML = `
      <h4>üì¢ Enviar Novedad</h4>
      <textarea id="broadcast-input" placeholder="Escribe una novedad..."></textarea>
      <button id="broadcast-send">‚û§</button>
    `;

          userList.appendChild(toggleBroadcast);
          userList.appendChild(broadcastContainer);

          // Mostrar / ocultar panel
          toggleBroadcast.onclick = () => {
            broadcastContainer.style.display =
              broadcastContainer.style.display === "flex" ? "none" : "flex";
          };

          // Enviar mensaje global
          broadcastContainer
            .querySelector("#broadcast-send")
            .addEventListener("click", async () => {
              const text = document
                .getElementById("broadcast-input")
                .value.trim();
              if (!text) {
                alert("Por favor escribe un mensaje.");
                return;
              }
              await sendBroadcastMessage(text);
              document.getElementById("broadcast-input").value = "";
            });
        }

        const btnGroup = document.createElement("button");
        btnGroup.textContent = "‚ûï Crear Grupo";
        btnGroup.id = "create-group-btn";
        btnGroup.style.cssText = `
    margin: 10px auto;
    width: 90%;
    padding: 8px;
    background: #00bcd4;
    color: white;
    border: none;
    border-radius: 6px;
    cursor: pointer;
  `;
        btnGroup.onclick = createGroup;
        userList.appendChild(btnGroup);

        // üîπ Cargar el resto de usuarios normales - CON CORRECCI√ìN PARA EVITAR DUPLICADOS
        const usersSnap = await getDocs(collection(db, "usuarios"));
        const existingUsers = new Set(); // üî• Usar Set para evitar duplicados

        usersSnap.forEach((u) => {
          const data = u.data();

          if (data.nombre === "Admin" && currentUser !== "Miguel") return;
          if (data.nombre === currentUser) return;

          // üî• Verificar si el usuario ya fue procesado
          if (existingUsers.has(data.nombre)) return;
          existingUsers.add(data.nombre);

          const div = document.createElement("div");
          div.classList.add("user-item");
          div.dataset.name = data.nombre;

          const avatar = document.createElement("div");
          avatar.classList.add("user-avatar");
          avatar.textContent = data.nombre.charAt(0).toUpperCase();

          const name = document.createElement("span");
          name.textContent = data.nombre;

          div.appendChild(avatar);
          div.appendChild(name);

          const badge = document.createElement("span");
          badge.classList.add("unread-badge");
          badge.id = `badge_${data.nombre}`;
          badge.textContent = "0";
          div.appendChild(badge);

          div.onclick = () => {
            document
              .querySelectorAll(".user-item")
              .forEach((el) => el.classList.remove("active"));
            div.classList.add("active");
            openPrivateChat(data.nombre);
            closeMenuOnMobile();
          };

          userList.appendChild(div);
        });

        // === üîπ Mostrar Grupos ===
        const gruposSnap = await getDocs(collection(db, "grupos"));

        // Verificar tambi√©n en grupos eliminados
        const deletedGroupsSnap = await getDocs(
          collection(db, "gruposEliminados")
        );
        const deletedGroupIds = deletedGroupsSnap.docs.map((doc) => doc.id);

        const existingGroups = new Set(); // üî• Usar Set para evitar grupos duplicados

        // En la parte donde creas los elementos de grupo en loadUserList:
        gruposSnap.forEach((g) => {
          if (deletedGroupIds.includes(g.id)) return;

          // üî• Verificar si el grupo ya fue procesado
          if (existingGroups.has(g.id)) return;
          existingGroups.add(g.id);

          const data = g.data();
          if (!data.miembros.includes(currentUser)) return;

          const div = document.createElement("div");
          div.classList.add("user-item");
          div.dataset.groupId = g.id;
          div.dataset.creador = data.creadoPor; // ‚Üê Guardar qui√©n cre√≥ el grupo
          div.innerHTML = `
      <div class="user-avatar">üë•</div>
      <span>${data.nombre}</span>
    `;

          // Agregar evento de click derecho para el men√∫ contextual
          div.addEventListener("contextmenu", (e) => {
            e.preventDefault();
            showGroupContextMenu(e, g.id, data.creadoPor, data.nombre);
          });

          div.onclick = () => {
            document
              .querySelectorAll(".user-item")
              .forEach((el) => el.classList.remove("active"));
            div.classList.add("active");
            openGroupChat(g.id, data.nombre);
          };
          userList.appendChild(div);
        });
      }

      // --- üîî Control de mensajes no le√≠dos ---
      function updateUnreadBadge(user, count) {
        const badge = document.getElementById(`badge_${user}`);
        if (!badge) return;
        if (count > 0) {
          badge.style.display = "inline-block";
          badge.textContent = count;
        } else {
          badge.style.display = "none";
        }
      }

      // üü© Ordenar la lista de usuarios por el √∫ltimo mensaje recibido o enviado
      async function sortUserListByLastMessage() {
        const userList = document.getElementById("user-list");
        const userItems = [
          ...userList.querySelectorAll(".user-item:not(.admin-item)"),
        ];

        const usersWithTimestamps = await Promise.all(
          userItems.map(async (div) => {
            const otherUser = div.dataset.name;
            const chatId = getChatId(currentUser, otherUser);
            const chatRef = doc(db, "chatsPrivados", chatId);
            const chatSnap = await getDoc(chatRef);
            let time = 0;
            if (chatSnap.exists() && chatSnap.data().ultimoMensaje) {
              const ts = chatSnap.data().ultimoMensaje;
              time = ts.toMillis ? ts.toMillis() : Date.parse(ts);
            }
            return { div, time };
          })
        );

        // üîπ Primero los que tienen mensajes, los sin mensajes al final
        usersWithTimestamps.sort((a, b) => {
          if (a.time === 0 && b.time === 0) return 0;
          if (a.time === 0) return 1;
          if (b.time === 0) return -1;
          return b.time - a.time;
        });

        usersWithTimestamps.forEach(({ div }) => userList.appendChild(div));
      }

      let currentChatUnsub = null; // üÜï global

      async function openPrivateChat(otherUser) {
        const messagesContainer = document.getElementById("chat-messages");
        messagesContainer.innerHTML = "";
        activeChatWith = otherUser;

        document
          .querySelectorAll(".user-item")
          .forEach((el) => el.classList.remove("active"));
        const currentDiv = [...document.querySelectorAll(".user-item")].find(
          (d) => d.dataset.name === otherUser
        );
        if (currentDiv) currentDiv.classList.add("active");

        activeChatId = getChatId(currentUser, otherUser);
        updateChatHeader(`${otherUser}`);

        // üßπ Cancelar escucha del chat anterior
        if (currentChatUnsub) {
          currentChatUnsub();
          currentChatUnsub = null;
        }

        // üü¢ Escuchar solo el chat activo
        const q = query(
          collection(db, "chatsPrivados", activeChatId, "mensajes"),
          where("timestamp", "!=", null),
          orderBy("timestamp")
        );

        currentChatUnsub = onSnapshot(q, (snapshot) => {
          const messagesContainer = document.getElementById("chat-messages");
          messagesContainer.innerHTML = "";

          let lastDate = null;
          const ocultosKey = `${currentUser}_ocultos_${activeChatId}`;
          const mensajesOcultos = JSON.parse(
            localStorage.getItem(ocultosKey) || "[]"
          );

          let firstSender = null;

          snapshot.forEach((docSnap) => {
            const msg = docSnap.data();
            if (!firstSender && msg.usuario) {
              firstSender = msg.usuario;
            }
            const msgId = docSnap.id;

            if (mensajesOcultos.includes(msgId)) return;
            if (!msg.timestamp) return;

            const msgDate =
              typeof msg.timestamp.toDate === "function"
                ? msg.timestamp.toDate()
                : new Date(msg.timestamp);

            const msgDayKey = msgDate.toDateString();

            if (msgDayKey !== lastDate) {
              lastDate = msgDayKey;
              const separator = document.createElement("div");
              separator.classList.add("date-separator");
              separator.textContent = getDateLabel(msgDate);
              messagesContainer.appendChild(separator);
            }

            const messageElement = document.createElement("div");
            messageElement.classList.add(
              "message",
              msg.usuario === currentUser ? "sent" : "received"
            );
            messageElement.dataset.id = msgId;

            if (msg.tipo === "broadcast") {
              messageElement.classList.add("broadcast");
            }

            // Si el mensaje es respuesta a otro, mostramos mini-cita arriba (clicable)
            if (msg.respuestaA && msg.respuestaA.id) {
              const mini = document.createElement("div");
              mini.classList.add("message-reply-mini");
              mini.style.fontSize = "12px";
              mini.style.padding = "6px 8px";
              mini.style.borderLeft = "3px solid rgba(0,0,0,0.08)";
              mini.style.marginBottom = "6px";
              mini.style.cursor = "pointer";
              mini.textContent = truncate(msg.respuestaA.texto, 80);
              // clic en la mini cita -> saltar al mensaje original
              mini.addEventListener("click", () => {
                scrollToMessage(msg.respuestaA.id);
              });
              messageElement.appendChild(mini);
            }

            const textSpan = document.createElement("span");
            textSpan.textContent = msg.texto;

            const timeSpan = document.createElement("span");
            timeSpan.classList.add("message-time");
            timeSpan.textContent = formatTime(msgDate);

            messageElement.appendChild(textSpan);
            messageElement.appendChild(timeSpan);

            // men√∫ contextual eliminar
            messageElement.addEventListener("contextmenu", (e) => {
              e.preventDefault();
              const oldMenu = document.querySelector(".context-menu");
              if (oldMenu) oldMenu.remove();

              const menu = document.createElement("div");
              menu.classList.add("context-menu");
              menu.innerHTML = `
  <button class="menu-reply">üí¨ Responder</button>
  <button class="menu-pin">${
    pinnedDataLocal && pinnedDataLocal.id === msgId
      ? "üìå Quitar fijado"
      : "üìå Fijar"
  }</button>
  <button class="menu-delete">üóëÔ∏è Eliminar</button>
`;
              document.body.appendChild(menu);

              // üìç Posicionar men√∫ en el lugar exacto del click
              const x = e.pageX;
              const y = e.pageY;
              menu.style.left = `${x}px`;
              menu.style.top = `${y}px`;

              // Evitar que se salga de la pantalla
              const rect = menu.getBoundingClientRect();
              if (rect.right > window.innerWidth)
                menu.style.left = `${window.innerWidth - rect.width - 10}px`;
              if (rect.bottom > window.innerHeight)
                menu.style.top = `${window.innerHeight - rect.height - 10}px`;

              // === ACCIONES ===

              // üí¨ RESPONDER
              menu
                .querySelector(".menu-reply")
                .addEventListener("click", (ev) => {
                  ev.stopPropagation();
                  menu.remove();
                  replyTo = {
                    id: msgId,
                    texto: msg.texto,
                    usuario: msg.usuario,
                  };
                  showReplyPreview(replyTo);
                });

              // üìå FIJAR / QUITAR FIJADO
              menu
                .querySelector(".menu-pin")
                .addEventListener("click", async (ev) => {
                  ev.stopPropagation();
                  menu.remove();

                  if (pinnedDataLocal && pinnedDataLocal.id === msgId) {
                    await unpinMessage(activeChatId);
                  } else {
                    await pinMessage(activeChatId, {
                      id: msgId,
                      texto: msg.texto,
                      usuario: msg.usuario,
                      fecha: new Date().toISOString(),
                    });
                  }
                });

              // üóëÔ∏è ELIMINAR
              menu
                .querySelector(".menu-delete")
                .addEventListener("click", async () => {
                  menu.remove();
                  if (msg.usuario === currentUser) {
                    await deleteDoc(
                      doc(db, "chatsPrivados", activeChatId, "mensajes", msgId)
                    );
                  } else {
                    const nuevosOcultos = [...mensajesOcultos, msgId];
                    localStorage.setItem(
                      ocultosKey,
                      JSON.stringify(nuevosOcultos)
                    );
                    const el = document.querySelector(
                      `.message[data-id="${msgId}"]`
                    );
                    if (el) el.remove();
                  }
                });

              document.addEventListener(
                "click",
                (ev) => {
                  if (!menu.contains(ev.target)) menu.remove();
                },
                { once: true }
              );
            });

            messagesContainer.appendChild(messageElement);
          });

          if (firstSender) {
            const startBox = document.createElement("div");
            startBox.classList.add("chat-start");
            startBox.textContent = `Chat comenzado por: ${firstSender}`;

            if (messagesContainer.firstChild) {
              messagesContainer.insertBefore(
                startBox,
                messagesContainer.firstChild
              );
            } else {
              messagesContainer.appendChild(startBox);
            }
          }

          messagesContainer.scrollTop = messagesContainer.scrollHeight;
          markMessagesAsRead(activeChatId);
        });

        attachPinnedListener(activeChatId);
        listenTypingStatus(otherUser);
        updateUnreadBadge(otherUser, 0);
        markMessagesAsRead(activeChatId);
        sessionStorage.setItem("lastChatWith", otherUser);
        sessionStorage.setItem("lastChatType", "private");
        sessionStorage.removeItem("lastChatId");
      }

      // --- Helper para normalizar timestamps ---
      function parseTimestamp(ts) {
        if (!ts) return new Date();

        // Si ya es un objeto Firestore Timestamp
        if (typeof ts.toDate === "function") return ts.toDate();

        // Si es un string tipo "31 de octubre de 2025, 6:53:57 p.m. UTC+1"
        if (typeof ts === "string") {
          // Intentar convertirlo a fecha con Date.parse no funcionar√° siempre, as√≠ que lo forzamos:
          try {
            // Eliminamos caracteres raros como el " " (espacio fino)
            const limpio = ts.replace(/\u202f/g, " ").replace(" ", " ");
            const fecha = new Date(limpio);
            if (!isNaN(fecha.getTime())) return fecha;
          } catch (e) {}
        }

        // Si nada funcion√≥, usar fecha actual
        return new Date();
      }

      function loadMessages(chatId) {
        const messagesContainer = document.getElementById("chat-messages");
        messagesContainer.innerHTML = "";

        const q = query(
          collection(db, "chatsPrivados", chatId, "mensajes"),
          where("timestamp", "!=", null),
          orderBy("timestamp")
        );

        // üü© Restaurar scroll si existe
        const savedScroll = sessionStorage.getItem(`scroll_${chatId}`);
        if (savedScroll) {
          setTimeout(() => {
            messagesContainer.scrollTop = parseInt(savedScroll);
          }, 200);
        }

        // üü© Guardar posici√≥n del scroll en tiempo real
        messagesContainer.addEventListener("scroll", () => {
          sessionStorage.setItem(
            `scroll_${chatId}`,
            messagesContainer.scrollTop
          );
        });

        onSnapshot(q, (snapshot) => {
          messagesContainer.innerHTML = "";
          let firstSender = null;

          const ocultosKey = `${currentUser}_ocultos_${chatId}`;
          const mensajesOcultos = JSON.parse(
            localStorage.getItem(ocultosKey) || "[]"
          );

          let lastDate = null; // üïì para saber cu√°ndo insertar separadores

          snapshot.forEach((docSnap) => {
            const msg = docSnap.data();
            const msgId = docSnap.id;

            if (!firstSender && msg.usuario) {
              firstSender = msg.usuario;
            }

            if (mensajesOcultos.includes(msgId)) return;

            // üî∏ Esperar hasta que Firestore tenga timestamp real
            if (!msg.timestamp && !firstSender && msg.usuario) {
              firstSender = msg.usuario;
            }

            const msgDate = parseTimestamp(msg.timestamp);
            const fechaMostrar = msg.fechaTexto || msg.timestamp;

            // --- Separador de fecha ---
            const msgDayKey = msgDate.toDateString();
            if (msgDayKey !== lastDate) {
              lastDate = msgDayKey;
              const separator = document.createElement("div");
              separator.classList.add("date-separator");
              separator.textContent = getDateLabel(msgDate);
              messagesContainer.appendChild(separator);
            }

            // --- Mensaje ---
            const messageElement = document.createElement("div");
            messageElement.classList.add(
              "message",
              msg.usuario === currentUser ? "sent" : "received"
            );
            messageElement.dataset.id = msgId;

            if (msg.tipo === "broadcast") {
              messageElement.classList.add("broadcast");
            }

            // Contenido del mensaje + hora
            // Si el mensaje es respuesta a otro, mostramos mini-cita arriba (clicable)
            if (msg.respuestaA && msg.respuestaA.id) {
              const mini = document.createElement("div");
              mini.classList.add("message-reply-mini");
              mini.style.fontSize = "12px";
              mini.style.padding = "6px 8px";
              mini.style.borderLeft = "3px solid rgba(0,0,0,0.08)";
              mini.style.marginBottom = "6px";
              mini.style.cursor = "pointer";
              mini.textContent = truncate(msg.respuestaA.texto, 80);
              // clic en la mini cita -> saltar al mensaje original
              mini.addEventListener("click", () => {
                scrollToMessage(msg.respuestaA.id);
              });
              messageElement.appendChild(mini);
            }

            const textSpan = document.createElement("span");
            textSpan.textContent = msg.texto;

            const timeSpan = document.createElement("span");
            timeSpan.classList.add("message-time");
            timeSpan.textContent = formatTime(msgDate);

            messageElement.appendChild(textSpan);
            messageElement.appendChild(timeSpan);

            // --- Men√∫ contextual eliminar ---
            messageElement.addEventListener("contextmenu", (e) => {
              e.preventDefault();
              const oldMenu = document.querySelector(".context-menu");
              if (oldMenu) oldMenu.remove();

              const menu = document.createElement("div");
              menu.classList.add("context-menu");
              menu.innerHTML = `
  <button class="menu-reply">üí¨ Responder</button>
  <button class="menu-pin">${
    pinnedDataLocal && pinnedDataLocal.id === msgId
      ? "üìå Quitar fijado"
      : "üìå Fijar"
  }</button>
  <button class="menu-delete">üóëÔ∏è Eliminar</button>
`;
              document.body.appendChild(menu);

              // üìç Posicionar men√∫ en el lugar exacto del click
              const x = e.pageX;
              const y = e.pageY;
              menu.style.left = `${x}px`;
              menu.style.top = `${y}px`;

              // Evitar que se salga de la pantalla
              const rect = menu.getBoundingClientRect();
              if (rect.right > window.innerWidth)
                menu.style.left = `${window.innerWidth - rect.width - 10}px`;
              if (rect.bottom > window.innerHeight)
                menu.style.top = `${window.innerHeight - rect.height - 10}px`;

              // === ACCIONES ===

              // üí¨ RESPONDER
              menu
                .querySelector(".menu-reply")
                .addEventListener("click", (ev) => {
                  ev.stopPropagation();
                  menu.remove();
                  replyTo = {
                    id: msgId,
                    texto: msg.texto,
                    usuario: msg.usuario,
                  };
                  showReplyPreview(replyTo);
                });

              // üìå FIJAR / QUITAR FIJADO
              menu
                .querySelector(".menu-pin")
                .addEventListener("click", async (ev) => {
                  ev.stopPropagation();
                  menu.remove();

                  if (pinnedDataLocal && pinnedDataLocal.id === msgId) {
                    await unpinMessage(activeChatId);
                  } else {
                    await pinMessage(activeChatId, {
                      id: msgId,
                      texto: msg.texto,
                      usuario: msg.usuario,
                      fecha: new Date().toISOString(),
                    });
                  }
                });

              // üóëÔ∏è ELIMINAR
              menu
                .querySelector(".menu-delete")
                .addEventListener("click", async () => {
                  menu.remove();
                  if (msg.usuario === currentUser) {
                    await deleteDoc(
                      doc(db, "chatsPrivados", activeChatId, "mensajes", msgId)
                    );
                  } else {
                    const nuevosOcultos = [...mensajesOcultos, msgId];
                    localStorage.setItem(
                      ocultosKey,
                      JSON.stringify(nuevosOcultos)
                    );
                    const el = document.querySelector(
                      `.message[data-id="${msgId}"]`
                    );
                    if (el) el.remove();
                  }
                });

              document.addEventListener(
                "click",
                (ev) => {
                  if (!menu.contains(ev.target)) menu.remove();
                },
                { once: true }
              );
            });

            messagesContainer.appendChild(messageElement);
          });

          // üü¶ Mostrar recuadro de inicio del chat si hay mensajes
          if (firstSender) {
            const startBox = document.createElement("div");
            startBox.classList.add("chat-start");
            startBox.textContent = `Chat comenzado por: ${firstSender}`;

            // Insertarlo al principio del contenedor
            if (messagesContainer.firstChild) {
              messagesContainer.insertBefore(
                startBox,
                messagesContainer.firstChild
              );
            } else {
              messagesContainer.appendChild(startBox);
            }
          }

          messagesContainer.scrollTop = messagesContainer.scrollHeight;
        });
      }

      // üî∏ Formato de hora: hh:mm
      function formatTime(date) {
        const hours = date.getHours().toString().padStart(2, "0");
        const minutes = date.getMinutes().toString().padStart(2, "0");
        return `${hours}:${minutes}`;
      }

      // üî∏ Texto de fecha: "Hoy", "Ayer" o "23 Octubre 2025"
      function getDateLabel(date) {
        const now = new Date();
        const dateCopy = new Date(date); // ‚úÖ Copia del objeto original

        // üîπ Crear copias para comparaci√≥n sin modificar las originales
        const nowMid = new Date(now);
        const dateMid = new Date(dateCopy);

        nowMid.setHours(0, 0, 0, 0);
        dateMid.setHours(0, 0, 0, 0);

        const diffDays = Math.floor((nowMid - dateMid) / 86400000);

        if (diffDays === 0) return "Hoy";
        if (diffDays === 1) return "Ayer";

        const meses = [
          "Enero",
          "Febrero",
          "Marzo",
          "Abril",
          "Mayo",
          "Junio",
          "Julio",
          "Agosto",
          "Septiembre",
          "Octubre",
          "Noviembre",
          "Diciembre",
        ];
        return `${dateCopy.getDate()} ${
          meses[dateCopy.getMonth()]
        } ${dateCopy.getFullYear()}`;
      }

      async function sendMessage() {
        const messageInput = document.getElementById("message-input");
        const text = messageInput.value.trim();

        // Ignorar comandos /menu y /men√∫
        const lower = text.toLowerCase();
        if (lower === "/menu" || lower === "/men√∫") {
          messageInput.value = "";
          return;
        }

        if (!text || !currentUser || !activeChatId) return;
        messageInput.value = "";

        const fecha = new Date();
        const fechaLegible = fecha.toLocaleString("es-ES", {
          dateStyle: "long",
          timeStyle: "medium",
        });

        const messageData = {
          texto: text,
          usuario: currentUser,
          timestamp: serverTimestamp(),
          fechaTexto: fechaLegible,
          check: false,
          respuestaA: replyTo
            ? { id: replyTo.id, texto: replyTo.texto, usuario: replyTo.usuario }
            : null,
        };

        // üîπ Ocultar barra de respuesta si hay
        if (replyTo) {
          hideReplyPreview();
        }

        const messagesContainer = document.getElementById("chat-messages");

        // --- Mostrar mensaje localmente
        const tempMessage = document.createElement("div");
        tempMessage.classList.add("message", "sent");
        tempMessage.innerHTML = `
    <span>${text}</span>
    <span class="message-time">${fechaLegible
      .split(",")[1]
      ?.trim()
      ?.slice(0, 5)}</span>
  `;
        messagesContainer.appendChild(tempMessage);
        messagesContainer.scrollTop = messagesContainer.scrollHeight;

        // üü© Si es un grupo, guardarlo en la colecci√≥n de grupos
        // üü© Si es un grupo, enviarlo igual con messageData
        if (activeChatId.startsWith("grupo_")) {
          const groupRef = doc(db, "grupos", activeChatId);
          const groupSnap = await getDoc(groupRef);
          if (!groupSnap.exists()) {
            await setDoc(groupRef, {
              creado: new Date().toISOString(),
            });
          }

          await addDoc(
            collection(db, "grupos", activeChatId, "mensajes"),
            messageData
          );

          // üîπ Guardar el √∫ltimo mensaje para orden o vista previa futura
          await setDoc(
            groupRef,
            { ultimoMensaje: serverTimestamp() },
            { merge: true }
          );

          sortUserListByLastMessage();
          return;
        }

        // üü® Si es un chat privado (comportamiento normal)
        const chatRef = doc(db, "chatsPrivados", activeChatId);
        const chatSnap = await getDoc(chatRef);
        if (!chatSnap.exists()) {
          await setDoc(chatRef, {
            participantes: [currentUser, activeChatWith],
            creado: new Date().toISOString(),
          });
        }

        console.log("üì© Enviando a:", activeChatId);

        await addDoc(
          collection(db, "chatsPrivados", activeChatId, "mensajes"),
          messageData
        );

        await setDoc(
          doc(db, "chatsPrivados", activeChatId),
          { ultimoMensaje: serverTimestamp() },
          { merge: true }
        );

        sortUserListByLastMessage();
      }

      // enter = enviar
      window.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          const loginVisible =
            document.getElementById("login-container").style.display !== "none";
          if (loginVisible) login();
          else sendMessage();
        }
      });

      async function sendBroadcastMessage(text) {
        const usersSnap = await getDocs(collection(db, "usuarios"));
        const fecha = new Date();
        const fechaLegible = fecha.toLocaleString("es-ES", {
          dateStyle: "long",
          timeStyle: "medium",
        });

        // üîπ Enviar a cada usuario (incluido el remitente)
        for (const u of usersSnap.docs) {
          const data = u.data();
          const nombre = data.nombre;
          if (!nombre) continue;

          const chatId = `${nombre}_self`; // ‚úÖ Chat personal del usuario

          const messageData = {
            texto: `üì¢ Novedades: ${text}`,
            usuario: currentUser,
            timestamp: serverTimestamp(),
            fechaTexto: fechaLegible,
            check: false,
            tipo: "broadcast", // üü¶ etiqueta especial
          };

          // Crear documento del chat personal si no existe
          await setDoc(
            doc(db, "chatsPrivados", chatId),
            { participantes: [nombre], creado: new Date().toISOString() },
            { merge: true }
          );

          // Agregar el mensaje dentro del chat personal
          await addDoc(
            collection(db, "chatsPrivados", chatId, "mensajes"),
            messageData
          );

          // Actualizar timestamp del √∫ltimo mensaje
          await setDoc(
            doc(db, "chatsPrivados", chatId),
            { ultimoMensaje: serverTimestamp() },
            { merge: true }
          );
        }

        // üîπ Cerrar panel y limpiar input despu√©s de enviar
        document.getElementById("broadcast-input").value = "";
        document.getElementById("broadcast-panel").style.display = "none";
      }

      async function createGroup() {
        const usersSnap = await getDocs(collection(db, "usuarios"));
        const contacts = usersSnap.docs
          .map((u) => u.data().nombre)
          .filter((u) => u !== currentUser);

        // Crear elementos del popup
        const overlay = document.createElement("div");
        overlay.className = "popup-overlay";

        const popup = document.createElement("div");
        popup.className = "popup";

        // Paso 1: seleccionar contactos
        popup.innerHTML = `
    <h3>Selecciona los miembros del grupo</h3>
    <div class="contact-list">
      ${contacts
        .map(
          (c) =>
            `<div class="contact-item" data-name="${c}">
              <input type="checkbox" id="chk_${c}">
              <label for="chk_${c}">${c}</label>
            </div>`
        )
        .join("")}
    </div>
    <button id="next-step">Siguiente ‚û§</button>
  `;

        overlay.appendChild(popup);
        document.body.appendChild(overlay);

        // Selecci√≥n de contactos
        popup.querySelectorAll(".contact-item").forEach((item) => {
          item.addEventListener("click", () => {
            const checkbox = item.querySelector("input");
            checkbox.checked = !checkbox.checked;
            item.classList.toggle("selected", checkbox.checked);
          });
        });

        // Paso 2: pedir nombre
        popup.querySelector("#next-step").addEventListener("click", () => {
          const selected = [...popup.querySelectorAll("input:checked")].map(
            (i) => i.id.replace("chk_", "")
          );

          if (selected.length === 0) {
            alert("Selecciona al menos un miembro para el grupo.");
            return;
          }

          popup.innerHTML = `
      <h3>Nombre del grupo</h3>
      <input type="text" id="group-name" placeholder="Ej: Equipo Alfa" style="width:100%;padding:10px;border-radius:6px;border:1px solid #ccc;margin-bottom:15px;">
      <button id="finish-group">Finalizar ‚úÖ</button>
    `;

          popup
            .querySelector("#finish-group")
            .addEventListener("click", async () => {
              const groupName = popup.querySelector("#group-name").value.trim();
              if (!groupName) {
                alert("Escribe un nombre para el grupo.");
                return;
              }

              const groupId = "grupo_" + Date.now();
              const members = [currentUser, ...selected];

              await setDoc(doc(db, "grupos", groupId), {
                nombre: groupName,
                miembros: members,
                creadoPor: currentUser,
                creado: new Date().toISOString(),
              });

              document.body.removeChild(overlay);
              await loadUserList();
            });
        });

        // Cerrar si haces click fuera del popup
        overlay.addEventListener("click", (e) => {
          if (e.target === overlay) document.body.removeChild(overlay);
        });
      }

      async function openGroupChat(groupId, groupName) {
        activeChatId = groupId;
        activeChatWith = groupName;
        updateChatHeader(`üë• ${groupName}`);

        const messagesContainer = document.getElementById("chat-messages");
        messagesContainer.innerHTML = "";

        const groupRef = doc(db, "grupos", groupId);
        const groupSnap = await getDoc(groupRef);
        const groupData = groupSnap.exists() ? groupSnap.data() : {};
        const creador = groupData.creadoPor || "Desconocido";

        // üü¶ Mostrar mensaje de encabezado
        const startBox = document.createElement("div");
        startBox.classList.add("chat-start");
        startBox.textContent = `Grupo creado por: ${creador}`;
        messagesContainer.appendChild(startBox);

        const q = query(
          collection(db, "grupos", groupId, "mensajes"),
          where("timestamp", "!=", null),
          orderBy("timestamp")
        );

        // Cancelar escucha previa si existe
        if (currentChatUnsub) {
          currentChatUnsub();
          currentChatUnsub = null;
        }

        listenGroupTypingStatus(groupId);

        currentChatUnsub = onSnapshot(q, (snapshot) => {
          // No vaciamos el mensaje inicial
          messagesContainer.innerHTML = "";
          messagesContainer.appendChild(startBox);

          // üîπ CLAVE: Obtener mensajes ocultos para este grupo
          const ocultosKey = `${currentUser}_ocultos_grupo_${groupId}`;
          const mensajesOcultos = JSON.parse(
            localStorage.getItem(ocultosKey) || "[]"
          );

          let lastDate = null;

          snapshot.forEach((docSnap) => {
            const msg = docSnap.data();
            const msgId = docSnap.id;

            // üîπ CLAVE: Saltar mensajes que est√°n en la lista de ocultos
            if (mensajesOcultos.includes(msgId)) return;

            if (!msg.timestamp) return;

            const msgDate =
              typeof msg.timestamp.toDate === "function"
                ? msg.timestamp.toDate()
                : new Date(msg.timestamp);

            // --- Separador de fecha ---
            const msgDayKey = msgDate.toDateString();
            if (msgDayKey !== lastDate) {
              lastDate = msgDayKey;
              const separator = document.createElement("div");
              separator.classList.add("date-separator");
              separator.textContent = getDateLabel(msgDate);
              messagesContainer.appendChild(separator);
            }

            // --- Crear mensaje ---
            const messageElement = document.createElement("div");
            messageElement.classList.add(
              "message",
              msg.usuario === currentUser ? "sent" : "received"
            );
            messageElement.dataset.id = msgId;

            // üß© L√çNEA 1: Avatar y nombre
            const headerLine = document.createElement("div");
            headerLine.style.display = "flex";
            headerLine.style.alignItems = "center";
            headerLine.style.gap = "8px";
            headerLine.style.marginBottom = "4px";

            // Avatar
            const avatar = document.createElement("div");
            avatar.classList.add("user-avatar", "small");
            avatar.textContent = msg.usuario.charAt(0).toUpperCase();

            // Nombre del remitente
            const nameLabel = document.createElement("span");
            nameLabel.style.fontSize = "12px";
            nameLabel.style.fontWeight = "bold";
            nameLabel.textContent = msg.usuario;

            headerLine.appendChild(avatar);
            headerLine.appendChild(nameLabel);

            // üß© L√çNEA 2: Contenido del mensaje
            const contentLine = document.createElement("div");
            contentLine.style.marginBottom = "4px";

            // üîπ Recuadro de respuesta
            if (msg.respuestaA && msg.respuestaA.id) {
              const mini = document.createElement("div");
              mini.classList.add("message-reply-mini");
              mini.style.fontSize = "12px";
              mini.style.padding = "6px 8px";
              mini.style.borderLeft = "3px solid rgba(0,0,0,0.08)";
              mini.style.marginBottom = "6px";
              mini.style.cursor = "pointer";
              mini.textContent = truncate(msg.respuestaA.texto, 80);
              mini.addEventListener("click", () => {
                scrollToMessage(msg.respuestaA.id);
              });
              contentLine.appendChild(mini);
            }

            // Texto del mensaje
            const textSpan = document.createElement("span");
            textSpan.textContent = msg.texto;
            contentLine.appendChild(textSpan);

            // üß© L√çNEA 3: Hora
            const timeLine = document.createElement("div");
            const timeSpan = document.createElement("span");
            timeSpan.classList.add("message-time");
            timeSpan.textContent = formatTime(msgDate);
            timeLine.appendChild(timeSpan);

            // Agregar todas las l√≠neas al mensaje
            messageElement.appendChild(headerLine);
            messageElement.appendChild(contentLine);
            messageElement.appendChild(timeLine);

            // üîπ Alinear mensajes propios a la derecha, ajenos a la izquierda
            if (msg.usuario === currentUser) {
              messageElement.style.alignSelf = "flex-end";
              messageElement.style.marginLeft = "auto";
              messageElement.style.marginRight = "0";
            } else {
              messageElement.style.alignSelf = "flex-start";
              messageElement.style.marginLeft = "0";
              messageElement.style.marginRight = "auto";
            }

            // === üü¶ MEN√ö CONTEXTUAL PARA GRUPOS ===
            messageElement.addEventListener("contextmenu", (e) => {
              e.preventDefault();
              const oldMenu = document.querySelector(".context-menu");
              if (oldMenu) oldMenu.remove();

              const menu = document.createElement("div");
              menu.classList.add("context-menu");
              menu.innerHTML = `
  <button class="menu-reply">üí¨ Responder</button>
  <button class="menu-pin">${
    pinnedDataLocal && pinnedDataLocal.id === msgId
      ? "üìå Quitar fijado"
      : "üìå Fijar"
  }</button>
  <button class="menu-delete">üóëÔ∏è ${
    msg.usuario === currentUser ? "Eliminar" : "Eliminar"
  }</button>
`;

              document.body.appendChild(menu);

              // üìç Posicionar men√∫ en el lugar exacto del click
              const x = e.pageX;
              const y = e.pageY;
              menu.style.left = `${x}px`;
              menu.style.top = `${y}px`;

              // Evitar que se salga de la pantalla
              const rect = menu.getBoundingClientRect();
              if (rect.right > window.innerWidth)
                menu.style.left = `${window.innerWidth - rect.width - 10}px`;
              if (rect.bottom > window.innerHeight)
                menu.style.top = `${window.innerHeight - rect.height - 10}px`;

              // === ACCIONES PARA GRUPOS ===

              // üí¨ RESPONDER
              menu
                .querySelector(".menu-reply")
                .addEventListener("click", (ev) => {
                  ev.stopPropagation();
                  menu.remove();
                  replyTo = {
                    id: msgId,
                    texto: msg.texto,
                    usuario: msg.usuario,
                  };
                  showReplyPreview(replyTo);
                });

              // üìå FIJAR / QUITAR FIJADO (para grupos usamos la misma colecci√≥n de grupos)
              menu
                .querySelector(".menu-pin")
                .addEventListener("click", async (ev) => {
                  ev.stopPropagation();
                  menu.remove();

                  if (pinnedDataLocal && pinnedDataLocal.id === msgId) {
                    await unpinGroupMessage(groupId);
                  } else {
                    await pinGroupMessage(groupId, {
                      id: msgId,
                      texto: msg.texto,
                      usuario: msg.usuario,
                      fecha: new Date().toISOString(),
                    });
                  }
                });

              // üóëÔ∏è ELIMINAR/OCULTAR
              menu
                .querySelector(".menu-delete")
                .addEventListener("click", async () => {
                  menu.remove();
                  if (msg.usuario === currentUser) {
                    // El usuario puede eliminar sus propios mensajes
                    await deleteDoc(
                      doc(db, "grupos", groupId, "mensajes", msgId)
                    );
                  } else {
                    // Para mensajes de otros, ocultarlos localmente
                    const nuevosOcultos = [...mensajesOcultos, msgId];
                    localStorage.setItem(
                      ocultosKey,
                      JSON.stringify(nuevosOcultos)
                    );
                    const el = document.querySelector(
                      `.message[data-id="${msgId}"]`
                    );
                    if (el) el.remove();
                  }
                });

              document.addEventListener(
                "click",
                (ev) => {
                  if (!menu.contains(ev.target)) menu.remove();
                },
                { once: true }
              );
            });

            // Agregar el mensaje al contenedor
            messagesContainer.appendChild(messageElement);
          });

          messagesContainer.scrollTop = messagesContainer.scrollHeight;
        });

        attachGroupPinnedListener(groupId);
        sessionStorage.setItem("lastChatWith", groupName);
        sessionStorage.setItem("lastChatType", "group");
        sessionStorage.setItem("lastChatId", groupId);
      }

      window.addEventListener("load", () => {
        document.querySelectorAll("input").forEach((i) => (i.value = ""));
      });

      // üîπ Funci√≥n para insertar el ‚ò∞ si estamos en m√≥vil
      function ensureMenuIcon() {
        const overlay = document.getElementById("overlay");

        if (window.innerWidth <= 768) {
          if (!chatHeader.querySelector(".menu-icon")) {
            const menuIcon = document.createElement("span");
            menuIcon.textContent = "‚ò∞";
            menuIcon.classList.add("menu-icon");
            chatHeader.prepend(menuIcon);

            // üîπ abrir/cerrar men√∫ y overlay
            menuIcon.addEventListener("click", () => {
              userList.classList.toggle("show");
              overlay.classList.toggle("show");
            });

            // üîπ cerrar si se toca el fondo oscuro
            overlay.addEventListener("click", () => {
              userList.classList.remove("show");
              overlay.classList.remove("show");
            });
          }
        } else {
          const icon = chatHeader.querySelector(".menu-icon");
          if (icon) icon.remove();
          overlay.classList.remove("show");
        }
      }

      // ‚úÖ Mantener sesi√≥n si recargas (estable en m√≥vil y escritorio)
      window.addEventListener("load", async () => {
        document.querySelectorAll("input").forEach((i) => (i.value = ""));

        currentUser = sessionStorage.getItem("currentUser");
        if (!currentUser) return;

        // Mostrar interfaz de chat
        document.getElementById("login-container").style.display = "none";
        document.getElementById("chat-container").style.display = "flex";

        // Aseguramos que el men√∫ est√° cerrado al inicio
        userList.classList.remove("show");

        // Cargamos los usuarios antes de restaurar el chat
        await loadUserList();
        listenForIncomingMessages();

        // Esperamos un poco para asegurar que la lista se renderiza correctamente
        const lastChat = sessionStorage.getItem("lastChatWith") || "Admin";
        const lastChatType =
          sessionStorage.getItem("lastChatType") || "private"; // "private" o "group"
        const lastChatId = sessionStorage.getItem("lastChatId"); // Para grupos

        const restoreChat = async () => {
          const userItems = document.querySelectorAll(".user-item");
          if (userItems.length === 0) return setTimeout(restoreChat, 100);

          // ‚úÖ Si es un grupo
          if (lastChatType === "group" && lastChatId) {
            const groupItem = [...document.querySelectorAll(".user-item")].find(
              (d) => d.dataset.groupId === lastChatId
            );
            if (groupItem) {
              const groupName = groupItem.querySelector("span").textContent;
              await openGroupChat(lastChatId, groupName);
            } else {
              // Si no encontramos el grupo, ir al chat personal
              await restorePersonalChat();
            }
          }
          // ‚úÖ Si es un chat privado con otro usuario
          else if (lastChat && lastChat !== "Admin") {
            await openPrivateChat(lastChat);
          }
          // ‚úÖ Chat personal del usuario
          else {
            await restorePersonalChat();
          }

          // ‚úÖ Volver a colocar el bot√≥n ‚ò∞ en m√≥vil
          ensureMenuIcon();
        };

        const restorePersonalChat = async () => {
          activeChatWith = currentUser;
          activeChatId = `${currentUser}_self`;
          updateChatHeader(`${currentUser} (T√∫)`);
          loadMessages(activeChatId);
          sessionStorage.setItem("lastChatWith", currentUser);
          sessionStorage.setItem("lastChatType", "private");

          // ‚úÖ Marcar el contacto activo visualmente
          document
            .querySelectorAll(".user-item")
            .forEach((el) => el.classList.remove("active"));
          const activeUser = [...document.querySelectorAll(".user-item")].find(
            (d) => d.dataset.name === currentUser
          );
          if (activeUser) activeUser.classList.add("active");
        };

        // Ejecutar restauraci√≥n despu√©s de 400ms para m√≥viles lentos
        setTimeout(restoreChat, 400);
      });

      // ‚úÖ Mantener la sesi√≥n al recargar, pero borrarla al cerrar la pesta√±a
      let unloadTimer;

      document.addEventListener("visibilitychange", () => {
        if (document.visibilityState === "hidden") {
          // Si despu√©s de 1 segundo la pesta√±a sigue oculta, la consideramos cerrada
          unloadTimer = setTimeout(() => {
            // üßπ Limpiar toda la informaci√≥n temporal (usuario, chat activo, scroll, etc.)
            sessionStorage.clear();
          }, 1000);
        } else {
          clearTimeout(unloadTimer); // Si el usuario vuelve r√°pido (recarga o cambio de pesta√±a), no se borra
        }
      });

      // === ‚úçÔ∏è Indicador de "escribiendo..." ===
      let typingTimeout;
      const messageInput = document.getElementById("message-input");

      messageInput.addEventListener("input", async () => {
        if (!currentUser || !activeChatWith) return;

        if (activeChatId.startsWith("grupo_")) {
          // üü¶ Manejar escritura en grupos
          handleGroupTyping(activeChatId);
        } else {
          // Manejar escritura en chats privados (c√≥digo original)
          await setDoc(
            doc(db, "usuarios", currentUser),
            {
              escribiendo: true,
              escribiendoA: activeChatWith,
              ultimoPing: Date.now(),
            },
            { merge: true }
          );

          clearTimeout(typingTimeout);
          typingTimeout = setTimeout(async () => {
            await setDoc(
              doc(db, "usuarios", currentUser),
              {
                escribiendo: false,
                escribiendoA: null,
                ultimoPing: Date.now(),
              },
              { merge: true }
            );
          }, 2500);
        }
      });

      // üîπ Escuchar si el otro usuario est√° escribiendo
      let currentTypingUnsub = null; // üÜï global para controlar la suscripci√≥n activa

      function listenTypingStatus(otherUser) {
        const statusEl = document.getElementById("chat-status");
        if (!otherUser) return;

        // üü¶ Si es un grupo, usar l√≥gica diferente
        if (activeChatId.startsWith("grupo_")) {
          listenGroupTypingStatus(activeChatId);
          return;
        }

        // L√≥gica original para chats privados
        const ref = doc(db, "usuarios", otherUser);

        window.currentStatusUnsub = onSnapshot(ref, (snap) => {
          if (!snap.exists()) return;
          const data = snap.data();

          if (activeChatWith !== otherUser) return;

          if (data.escribiendo && data.escribiendoA === currentUser) {
            statusEl.textContent = "escribiendo...";
            statusEl.style.color = "#fff176";
            return;
          }

          const lastPing = data.ultimoPing || 0;
          const diff = (Date.now() - lastPing) / 1000;

          if (diff < 8) {
            statusEl.textContent = "en l√≠nea";
            statusEl.style.color = "#a5ffb0";
          } else if (diff < 60) {
            statusEl.textContent = "hace un momento";
            statusEl.style.color = "#b0bec5";
          } else {
            const fecha = data.ultimoAcceso
              ? data.ultimoAcceso.toDate
                ? data.ultimoAcceso.toDate()
                : new Date(data.ultimoAcceso)
              : new Date(lastPing);
            const diffMin = Math.floor((Date.now() - fecha.getTime()) / 60000);
            statusEl.textContent =
              diffMin < 60 ? `hace ${diffMin} min` : fecha.toLocaleDateString();
            statusEl.style.color = "#b0bec5";
          }
        });
      }

      function listenGroupTypingStatus(groupId) {
        const statusEl = document.getElementById("chat-status");

        // Obtener miembros del grupo
        const groupRef = doc(db, "grupos", groupId);

        onSnapshot(groupRef, async (groupSnap) => {
          if (!groupSnap.exists()) return;

          const groupData = groupSnap.data();
          const miembros = groupData.miembros || [];

          // Escuchar estado de todos los miembros
          const typingUsers = [];
          const onlineUsers = [];

          for (const member of miembros) {
            if (member === currentUser) continue; // No mostrar al usuario actual

            const userRef = doc(db, "usuarios", member);
            const userSnap = await getDoc(userRef);

            if (userSnap.exists()) {
              const userData = userSnap.data();

              // Verificar si est√° escribiendo en este grupo
              if (userData.escribiendo && userData.escribiendoA === groupId) {
                typingUsers.push(member);
              }

              // Verificar si est√° en l√≠nea
              const lastPing = userData.ultimoPing || 0;
              const diff = (Date.now() - lastPing) / 1000;
              if (diff < 8) {
                onlineUsers.push(member);
              }
            }
          }

          // Actualizar estado del grupo
          if (typingUsers.length > 0) {
            if (typingUsers.length === 1) {
              statusEl.textContent = `${typingUsers[0]} est√° escribiendo...`;
            } else if (typingUsers.length === 2) {
              statusEl.textContent = `${typingUsers[0]} y ${typingUsers[1]} est√°n escribiendo...`;
            } else {
              statusEl.textContent = `${typingUsers[0]} y ${
                typingUsers.length - 1
              } m√°s est√°n escribiendo...`;
            }
            statusEl.style.color = "#fff176";
          } else if (onlineUsers.length > 0) {
            if (onlineUsers.length === 1) {
              statusEl.textContent = `${onlineUsers[0]} est√° en l√≠nea`;
            } else if (onlineUsers.length === 2) {
              statusEl.textContent = `${onlineUsers[0]} y ${onlineUsers[1]} en l√≠nea`;
            } else {
              statusEl.textContent = `${onlineUsers[0]} y ${
                onlineUsers.length - 1
              } m√°s en l√≠nea`;
            }
            statusEl.style.color = "#a5ffb0";
          } else {
            statusEl.textContent = "Todos desconectados";
            statusEl.style.color = "#b0bec5";
          }
        });
      }

      function handleGroupTyping(groupId) {
        if (!currentUser || !groupId) return;

        // Marcar escribiendo en el grupo
        setDoc(
          doc(db, "usuarios", currentUser),
          {
            escribiendo: true,
            escribiendoA: groupId,
            ultimoPing: Date.now(),
          },
          { merge: true }
        );

        clearTimeout(typingTimeout);
        typingTimeout = setTimeout(async () => {
          await setDoc(
            doc(db, "usuarios", currentUser),
            {
              escribiendo: false,
              escribiendoA: null,
              ultimoPing: Date.now(),
            },
            { merge: true }
          );
        }, 2500);
      }

      // ---------- Mostrar / ocultar preview de respuesta ----------
      function showReplyPreview(msgObj) {
        const preview = document.getElementById("reply-preview");
        preview.innerHTML = `
    <div style="font-size:12px;color:#666;">${escapeHtml(
      msgObj.usuario
    )} ¬∑ <span style="font-weight:700;">${truncate(
          msgObj.texto,
          80
        )}</span></div>
    <button class="reply-cancel" aria-label="Cancelar respuesta">‚úñ</button>
  `;
        preview.style.display = "flex";

        preview.querySelector(".reply-cancel").onclick = () => {
          replyTo = null;
          preview.style.display = "none";
        };
      }

      function hideReplyPreview() {
        const preview = document.getElementById("reply-preview");
        replyTo = null;
        preview.style.display = "none";
      }

      // ---------- Utilidades ----------
      function truncate(str, n) {
        if (!str) return "";
        return str.length > n ? str.slice(0, n - 1) + "‚Ä¶" : str;
      }
      function escapeHtml(unsafe) {
        return (unsafe || "")
          .toString()
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;");
      }

      // ---------- Mostrar mensaje fijado (barra superior) ----------
      async function renderPinnedMessage(chatId, pinned) {
        const container = document.getElementById("pinned-message");
        if (!pinned) {
          container.style.display = "none";
          pinnedDataLocal = null;
          return;
        }
        pinnedDataLocal = pinned;
        // fondo igual que el header. Tomamos el color computado del header o fallback.
        const header = document.getElementById("chat-header");
        const style = getComputedStyle(header);
        const bg = style.backgroundColor || "#00bcd4";

        container.style.background = bg;
        container.innerHTML = `
    <span class="pin-icon">üìå</span>
    <div class="pin-text">${escapeHtml(pinned.usuario)}: ${escapeHtml(
          truncate(pinned.texto, 160)
        )}</div>
    <button class="pin-unpin" title="Quitar fijado">‚úñ</button>
  `;
        container.style.display = "flex";

        // al pulsar el bot√≥n ‚ùå quitar fijado (para todos)
        container.querySelector(".pin-unpin").onclick = async (e) => {
          e.stopPropagation();
          if (activeChatId.startsWith("grupo_")) {
            await unpinGroupMessage(activeChatId);
          } else {
            await unpinMessage(activeChatId);
          }
        };

        // al pulsar la barra, nos desplazamos al mensaje fijado
        container.onclick = () => {
          if (pinned && pinned.id) scrollToMessage(pinned.id);
        };
      }

      // ---------- Guardar / eliminar mensaje fijado en Firestore ----------
      async function pinMessage(chatId, messageObj) {
        // messageObj: { id, texto, usuario, fecha }
        await setDoc(
          doc(db, "chatsPrivados", chatId),
          {
            mensajeFijado: {
              id: messageObj.id,
              texto: messageObj.texto,
              usuario: messageObj.usuario,
              fecha: messageObj.fecha || new Date().toISOString(),
            },
          },
          { merge: true }
        );
      }

      async function unpinMessage(chatId) {
        await setDoc(
          doc(db, "chatsPrivados", chatId),
          { mensajeFijado: null },
          { merge: true }
        );
      }

      // ---------- Cargar mensaje fijado al abrir chat y escuchar cambios en el documento del chat ----------
      function attachPinnedListener(chatId) {
        const chatDocRef = doc(db, "chatsPrivados", chatId);
        // Removemos listener anterior si existiera
        if (window._pinnedUnsub) window._pinnedUnsub();
        window._pinnedUnsub = onSnapshot(chatDocRef, async (snap) => {
          if (!snap.exists()) return renderPinnedMessage(chatId, null);
          const data = snap.data();
          if (!data || !data.mensajeFijado) {
            renderPinnedMessage(chatId, null);
            return;
          }
          // Si la doc tiene mensajeFijado, lo renderizamos
          renderPinnedMessage(chatId, data.mensajeFijado);
        });
      }

      // ---------- Scroll y resaltado al mensaje (salto desde cita o fijado) ----------
      function scrollToMessage(msgId) {
        if (!msgId) return;
        const el = document.querySelector(`.message[data-id="${msgId}"]`);
        if (!el) return;
        // desplazamos y resaltamos
        const container = document.getElementById("chat-messages");
        const top = el.offsetTop - 80; // dejar algo de espacio arriba
        container.scrollTop = top;
        el.classList.remove("highlight");
        // forzar reflow para reiniciar la animaci√≥n si ya existe
        void el.offsetWidth;
        el.classList.add("highlight");
        // quitar clase pasado un tiempo
        setTimeout(() => el.classList.remove("highlight"), 2200);
      }

      window.login = login;
      window.sendMessage = sendMessage;

      const toggleButton = document.getElementById("toggle-user-list");
      const userList = document.getElementById("user-list");
      const chatHeader = document.getElementById("chat-header");

      // üëÇ Insertar el icono al cargar y al redimensionar
      window.addEventListener("resize", ensureMenuIcon);

      // üëÇ Cada vez que se cambie de chat o se actualice el header, volver a poner el ‚ò∞
      const originalSetText = (text) => {
        chatHeader.textContent = text;
        ensureMenuIcon();
      };

      // üî∏ Sobrescribimos los lugares donde se cambia el encabezado
      function updateChatHeader(name) {
        const chatName = document.getElementById("chat-name");
        const statusEl = document.getElementById("chat-status");

        if (chatName) chatName.textContent = name;
        ensureMenuIcon();

        // üü¢ Mostrar/ocultar barra de estado seg√∫n el tipo de chat
        if (activeChatWith === currentUser) {
          // Chat personal - ocultar estado
          statusEl.style.display = "none";
        } else if (activeChatId.startsWith("grupo_")) {
          // Grupo - mostrar estado especial para grupos
          statusEl.style.display = "block";
          statusEl.textContent = "Cargando...";
          statusEl.style.color = "#b0bec5";
        } else {
          // Chat privado - mostrar estado normal
          statusEl.style.display = "block";
        }
      }

      // ‚úÖ Cerrar el men√∫ de contactos autom√°ticamente en m√≥vil al abrir un chat
      function closeMenuOnMobile() {
        if (window.innerWidth <= 768) {
          userList.classList.remove("show");
          document.getElementById("overlay").classList.remove("show");
        }
      }

      // Escuchamos los clics en cada contacto cuando se cargan
      document.addEventListener("click", (e) => {
        const userItem = e.target.closest(".user-item");
        if (userItem) {
          closeMenuOnMobile();
        }
      });

      // üëá Cierra el men√∫ de usuarios si se hace clic fuera (solo en m√≥vil)
      document.addEventListener("click", (event) => {
        const isMobile = window.innerWidth <= 768;
        const menu = document.getElementById("user-list");
        const menuIcon = document.querySelector(".menu-icon");

        // Si no estamos en m√≥vil, no hacer nada
        if (!isMobile) return;

        // Si el men√∫ est√° abierto y el clic no fue dentro del men√∫ ni en el icono ‚ò∞ ‚Üí cerrar
        if (
          menu.classList.contains("show") &&
          !menu.contains(event.target) &&
          !menuIcon?.contains(event.target)
        ) {
          menu.classList.remove("show");
        }
      });

      // üü¶ Animaci√≥n al hacer scroll en el chat
      const chatMessages = document.getElementById("chat-messages");
      let lastScrollTop = 0;

      chatMessages.addEventListener("scroll", () => {
        const currentScroll = chatMessages.scrollTop;
        if (currentScroll > lastScrollTop) {
          // üîΩ bajando
          chatMessages.classList.add("scroll-down");
          chatMessages.classList.remove("scroll-up");
        } else if (currentScroll < lastScrollTop) {
          // üîº subiendo
          chatMessages.classList.add("scroll-up");
          chatMessages.classList.remove("scroll-down");
        }

        lastScrollTop = currentScroll <= 0 ? 0 : currentScroll;

        clearTimeout(chatMessages._animTimer);
        chatMessages._animTimer = setTimeout(() => {
          chatMessages.classList.remove("scroll-up", "scroll-down");
        }, 400);
      });

      // ‚úÖ Sobrescribir sendMessage despu√©s de definirla
      const originalSendMessage = window.sendMessage;

      // üü¶ Detectar /menu o /men√∫ en tu chat personal
      async function handleMenuCommand() {
        if (
          !currentUser ||
          !(
            activeChatId &&
            activeChatId.includes(currentUser) &&
            activeChatId.includes("admin")
          )
        ) {
          alert("‚ö†Ô∏è Este comando solo funciona en tu chat personal.");
          return;
        }

        // Crear modal
        let modal = document.getElementById("menu-modal");
        if (modal) modal.remove(); // por si ya existe

        modal = document.createElement("div");
        modal.id = "menu-modal";
        modal.style.position = "fixed";
        modal.style.inset = "0";
        modal.style.background = "rgba(0,0,0,0.4)";
        modal.style.display = "flex";
        modal.style.justifyContent = "center";
        modal.style.alignItems = "center";
        modal.style.zIndex = "2000";
        modal.innerHTML = `
      <div style="background:white;padding:20px;border-radius:10px;max-width:320px;width:90%;box-shadow:0 4px 10px rgba(0,0,0,0.3);">
        <h3 style="margin-top:0;color:#00bcd4;">‚öôÔ∏è Configuraci√≥n de cuenta</h3>
        <label>Nuevo nombre:</label>
        <input id="new-username" type="text" style="width:100%;padding:8px;margin:6px 0;border:1px solid #ccc;border-radius:5px;" placeholder="${currentUser}" />
        <label>Nueva contrase√±a:</label>
        <input id="new-password" type="password" style="width:100%;padding:8px;margin:6px 0;border:1px solid #ccc;border-radius:5px;" placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢" />
        <div style="text-align:right;margin-top:10px;">
          <button id="cancel-menu" style="margin-right:8px;padding:6px 10px;border:none;background:#ccc;border-radius:5px;cursor:pointer;">Cancelar</button>
          <button id="save-menu" style="padding:6px 10px;border:none;background:#00bcd4;color:white;border-radius:5px;cursor:pointer;">Guardar</button>
        </div>
      </div>
    `;
        document.body.appendChild(modal);

        document.getElementById("cancel-menu").onclick = () => modal.remove();
        document.getElementById("save-menu").onclick = async () => {
          const newUsername = document
            .getElementById("new-username")
            .value.trim();
          const newPassword = document
            .getElementById("new-password")
            .value.trim();
          if (!newUsername && !newPassword)
            return alert("Introduce un cambio.");

          const userRef = doc(db, "usuarios", currentUser);
          const updates = {};
          if (newUsername) updates.nombre = newUsername;
          if (newPassword) updates.password = newPassword;

          await setDoc(userRef, updates, { merge: true });

          if (newUsername) {
            sessionStorage.setItem("currentUser", newUsername);
            currentUser = newUsername;
            alert(
              "‚úÖ Nombre de usuario actualizado. Vuelve a iniciar sesi√≥n para ver los cambios."
            );
          } else {
            alert("‚úÖ Contrase√±a actualizada correctamente.");
          }

          modal.remove();
        };
      }

      // üîπ Interceptar env√≠o de mensajes
      window.sendMessage = async function () {
        const messageInput = document.getElementById("message-input");
        const text = messageInput.value.trim().toLowerCase();

        if (text === "/menu" || text === "/men√∫") {
          messageInput.value = "";
          await handleMenuCommand();
          return;
        }

        // Si no es el comando, sigue el env√≠o normal
        await originalSendMessage();
      };

      // reemplaza la versi√≥n anterior por esta
      async function markMessagesAsRead(chatId) {
        try {
          const msgsRef = collection(db, "chatsPrivados", chatId, "mensajes");
          const snap = await getDocs(msgsRef);

          // usar batch para hacer todos los setDoc en una √∫nica operaci√≥n
          const batch = writeBatch(db);
          let any = false;

          snap.forEach((docSnap) => {
            const msg = docSnap.data();
            if (msg.usuario !== currentUser && msg.check !== true) {
              const docRef = doc(
                db,
                "chatsPrivados",
                chatId,
                "mensajes",
                docSnap.id
              );
              batch.set(docRef, { check: true }, { merge: true });
              any = true;
            }
          });

          if (any) await batch.commit();
        } catch (err) {
          console.error("Error marcando mensajes como le√≠dos:", err);
        }
      }

      // === Bot√≥n de scroll al final ===
      function initScrollToBottomButton() {
        const scrollBtn = document.getElementById("scroll-to-bottom");
        const messagesContainer = document.getElementById("chat-messages");

        if (!scrollBtn || !messagesContainer) return;

        // Mostrar/ocultar bot√≥n basado en la posici√≥n del scroll
        messagesContainer.addEventListener("scroll", () => {
          const scrollThreshold = 200; // Aparece cuando est√°s a 200px del final
          const isNearBottom =
            messagesContainer.scrollHeight -
              messagesContainer.scrollTop -
              messagesContainer.clientHeight <=
            scrollThreshold;

          if (isNearBottom) {
            scrollBtn.classList.remove("visible");
          } else {
            scrollBtn.classList.add("visible");
          }
        });

        // Click en el bot√≥n: ir al final
        scrollBtn.addEventListener("click", () => {
          messagesContainer.scrollTop = messagesContainer.scrollHeight;
        });

        // Tambi√©n ocultar el bot√≥n cuando lleguemos al final por otros medios
        messagesContainer.addEventListener("scrollend", () => {
          const isAtBottom =
            messagesContainer.scrollHeight -
              messagesContainer.scrollTop -
              messagesContainer.clientHeight <=
            10;

          if (isAtBottom) {
            scrollBtn.classList.remove("visible");
          }
        });
      }

      // Funci√≥n para ir al final del chat (tambi√©n se puede llamar desde otros lugares)
      function scrollToBottom() {
        const messagesContainer = document.getElementById("chat-messages");
        if (messagesContainer) {
          messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }
      }

      // ---------- Guardar / eliminar mensaje fijado en GRUPOS ----------
      async function pinGroupMessage(groupId, messageObj) {
        await setDoc(
          doc(db, "grupos", groupId),
          {
            mensajeFijado: {
              id: messageObj.id,
              texto: messageObj.texto,
              usuario: messageObj.usuario,
              fecha: messageObj.fecha || new Date().toISOString(),
            },
          },
          { merge: true }
        );
      }

      async function unpinGroupMessage(groupId) {
        await setDoc(
          doc(db, "grupos", groupId),
          { mensajeFijado: null },
          { merge: true }
        );
      }

      // ---------- Cargar mensaje fijado en GRUPOS ----------
      function attachGroupPinnedListener(groupId) {
        const groupDocRef = doc(db, "grupos", groupId);
        // Removemos listener anterior si existiera
        if (window._groupPinnedUnsub) window._groupPinnedUnsub();
        window._groupPinnedUnsub = onSnapshot(groupDocRef, async (snap) => {
          if (!snap.exists()) return renderPinnedMessage(groupId, null);
          const data = snap.data();
          if (!data || !data.mensajeFijado) {
            renderPinnedMessage(groupId, null);
            return;
          }
          // Si el grupo tiene mensajeFijado, lo renderizamos
          renderPinnedMessage(groupId, data.mensajeFijado);
        });
      }

      // Funci√≥n para mostrar men√∫ contextual de grupos
      function showGroupContextMenu(event, groupId, creador, groupName) {
        // Solo permitir al creador eliminar el grupo
        if (creador !== currentUser) return;

        const oldMenu = document.querySelector(".context-menu");
        if (oldMenu) oldMenu.remove();

        const menu = document.createElement("div");
        menu.classList.add("context-menu");
        menu.innerHTML = `
      <button class="menu-delete-group">üóëÔ∏è Eliminar Grupo</button>
    `;

        document.body.appendChild(menu);

        // Posicionar el men√∫
        const x = event.pageX;
        const y = event.pageY;
        menu.style.left = `${x}px`;
        menu.style.top = `${y}px`;

        // Evitar que se salga de la pantalla
        const rect = menu.getBoundingClientRect();
        if (rect.right > window.innerWidth)
          menu.style.left = `${window.innerWidth - rect.width - 10}px`;
        if (rect.bottom > window.innerHeight)
          menu.style.top = `${window.innerHeight - rect.height - 10}px`;

        // Acci√≥n de eliminar grupo
        menu
          .querySelector(".menu-delete-group")
          .addEventListener("click", async () => {
            menu.remove();
            showDeleteGroupConfirmation(groupId, groupName);
          });

        // Cerrar men√∫ al hacer click fuera
        document.addEventListener(
          "click",
          (ev) => {
            if (!menu.contains(ev.target)) menu.remove();
          },
          { once: true }
        );
      }

      // Funci√≥n para eliminar grupo
      function showDeleteGroupConfirmation(groupId, groupName) {
        // Crear overlay del popup
        const overlay = document.createElement("div");
        overlay.className = "popup-overlay";
        overlay.id = "delete-group-overlay";

        // Crear popup de confirmaci√≥n
        const popup = document.createElement("div");
        popup.className = "popup";
        popup.innerHTML = `
      <h3>üóëÔ∏è Eliminar Grupo</h3>
      <p style="margin: 15px 0; color: #666; text-align: center;">
        ¬øEst√°s seguro de que quieres eliminar el grupo <strong>"${groupName}"</strong>?
      </p>
      <p style="margin: 10px 0; color: #ff4444; font-size: 14px; text-align: center;">
        ‚ö†Ô∏è Esta acci√≥n no se puede deshacer
      </p>
      <div style="display: flex; gap: 10px; margin-top: 20px;">
        <button id="cancel-delete-group" style="flex: 1; padding: 10px; background: #ccc; border: none; border-radius: 6px; cursor: pointer;">
          Cancelar
        </button>
        <button id="confirm-delete-group" style="flex: 1; padding: 10px; background: #ff4444; color: white; border: none; border-radius: 6px; cursor: pointer;">
          Eliminar
        </button>
      </div>
    `;

        overlay.appendChild(popup);
        document.body.appendChild(overlay);

        // Configurar eventos de los botones
        document.getElementById("cancel-delete-group").onclick = () => {
          document.body.removeChild(overlay);
        };

        document.getElementById("confirm-delete-group").onclick = async () => {
          document.body.removeChild(overlay);
          await deleteGroup(groupId, groupName);
        };

        // Cerrar al hacer click fuera del popup
        overlay.addEventListener("click", (e) => {
          if (e.target === overlay) {
            document.body.removeChild(overlay);
          }
        });
      }

      async function deleteGroup(groupId, groupName) {
        try {
          // Mostrar indicador de carga
          const loadingOverlay = document.createElement("div");
          loadingOverlay.className = "popup-overlay";
          loadingOverlay.innerHTML = `
      <div class="popup">
        <h3>Eliminando grupo...</h3>
        <p style="text-align: center;">Por favor espera</p>
      </div>
    `;
          document.body.appendChild(loadingOverlay);

          // 1. Obtener informaci√≥n del grupo antes de eliminarlo
          const groupRef = doc(db, "grupos", groupId);
          const groupSnap = await getDoc(groupRef);

          if (!groupSnap.exists()) {
            document.body.removeChild(loadingOverlay);
            alert("El grupo ya no existe");
            return;
          }

          const groupData = groupSnap.data();
          const miembros = groupData.miembros || [];

          // 2. Eliminar todos los mensajes del grupo primero
          const mensajesRef = collection(db, "grupos", groupId, "mensajes");
          const mensajesSnap = await getDocs(mensajesRef);

          const batch = writeBatch(db);
          mensajesSnap.forEach((docSnap) => {
            batch.delete(docSnap.ref);
          });
          await batch.commit();

          // 3. Eliminar el documento del grupo principal
          await deleteDoc(groupRef);

          // 4. Si existe un documento en gruposEliminados, eliminarlo tambi√©n
          const deletedGroupRef = doc(db, "gruposEliminados", groupId);
          const deletedGroupSnap = await getDoc(deletedGroupRef);
          if (deletedGroupSnap.exists()) {
            await deleteDoc(deletedGroupRef);
          }

          // 5. Si el grupo eliminado era el chat activo, redirigir al chat personal
          if (activeChatId === groupId) {
            activeChatWith = currentUser;
            activeChatId = `${currentUser}_self`;
            updateChatHeader(`${currentUser} (T√∫)`);
            loadMessages(activeChatId);

            // Actualizar selecci√≥n visual
            document
              .querySelectorAll(".user-item")
              .forEach((el) => el.classList.remove("active"));
            const adminItem = document.querySelector(".admin-item");
            if (adminItem) adminItem.classList.add("active");

            sessionStorage.setItem("lastChatWith", currentUser);
            sessionStorage.setItem("lastChatType", "private");
            sessionStorage.removeItem("lastChatId");
          }

          // 6. Recargar la lista de usuarios para quitar el grupo eliminado
          await loadUserList();

          // 7. Quitar el indicador de carga
          document.body.removeChild(loadingOverlay);

          console.log("‚úÖ Grupo eliminado completamente de la base de datos");
        } catch (error) {
          console.error("‚ùå Error al eliminar el grupo:", error);

          // Quitar el indicador de carga si existe
          const loadingOverlay = document.querySelector(".popup-overlay");
          if (
            loadingOverlay &&
            loadingOverlay.innerHTML.includes("Eliminando grupo")
          ) {
            document.body.removeChild(loadingOverlay);
          }

          alert("Error al eliminar el grupo. Int√©ntalo de nuevo.");
        }
      }

      // Funci√≥n para verificar grupos eliminados (se ejecuta peri√≥dicamente)
      function listenForDeletedGroups() {
        const deletedGroupsRef = collection(db, "gruposEliminados");

        onSnapshot(deletedGroupsRef, async (snapshot) => {
          const changes = snapshot.docChanges();

          for (const change of changes) {
            if (change.type === "added") {
              const deletedGroupData = change.doc.data();

              // Verificar si el usuario actual era miembro del grupo eliminado
              if (
                deletedGroupData.miembros &&
                deletedGroupData.miembros.includes(currentUser)
              ) {
                console.log(
                  `üì¢ El grupo "${deletedGroupData.nombre}" fue eliminado`
                );

                // Si el grupo eliminado es el chat activo, redirigir al chat personal
                if (activeChatId === deletedGroupData.grupoId) {
                  activeChatWith = currentUser;
                  activeChatId = `${currentUser}_self`;
                  updateChatHeader(`${currentUser} (T√∫)`);
                  loadMessages(activeChatId);

                  document
                    .querySelectorAll(".user-item")
                    .forEach((el) => el.classList.remove("active"));
                  const adminItem = document.querySelector(".admin-item");
                  if (adminItem) adminItem.classList.add("active");

                  sessionStorage.setItem("lastChatWith", currentUser);
                  sessionStorage.setItem("lastChatType", "private");
                  sessionStorage.removeItem("lastChatId");
                }

                // Recargar la lista de usuarios para reflejar el cambio
                await loadUserList();
              }
            }
          }
        });
      }
    </script>
  </body>
</html>
